{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Qseek \ud83d\udd25","text":"<p>Qseek is an earthquake detection and localisation framework. It combines modern machine learning phase detection and robust migration and stacking techniques.</p> <p>The detector is leveraging Pyrocko and SeisBench, it is highly-performant and can search massive data sets for seismic activity efficiently.</p> <p>Citation</p> <p>Isken, M., Niemz, P., M\u00fcnchmeyer, J., B\u00fcy\u00fckakp\u0131nar, P., Heimann, S., Cesca, S., Vasyura-Bathke, H., &amp; Dahm, T. (2025). Qseek: A data-driven Framework for Automated Earthquake Detection, Localization and Characterization. Seismica, 4(1). https://doi.org/10.26443/seismica.v4i1.1283</p> <p></p> <p>Seismic swarm activity in Iceland, Reykjanes Peninsula during a 2020 unrest. 30k+ earthquakes detected, outlining a dike intrusion, preceeding the 2021 Fagradasfjall eruption.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Earthquake phase detection using machine-learning pickers from SeisBench</li> <li> PhaseNet (Zhu and Beroza, 2018</li> <li> EQTransformer (Mousavi et al., 2020)</li> <li> OBSTransformer (Niksejel and Zahng, 2024)</li> <li> LFEDetect</li> <li> Octree localisation approach for efficient and accurate search</li> <li> Different velocity models:</li> <li> Constant velocity</li> <li> 1D Layered velocity model</li> <li> 3D fast-marching velocity model (NonLinLoc compatible)</li> <li> Extraction of earthquake event features:</li> <li> Local magnitudes</li> <li> Ground motion attributes</li> <li> Automatic extraction of modelled and picked travel times</li> <li> Calculation and application of station corrections / station delay times</li> <li> Real-time analytics on streaming data (e.g. SeedLink)</li> </ul> <p>Get Started!</p>"},{"location":"#supported-by","title":"Supported by","text":""},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#computation-performance","title":"Computation Performance","text":"<p>Qseek is built for searching in large-N data sets. The implementation is leveraging Python <code>asyncio</code> heavily to implement threading and keeping the CPU busy. It is built on top of highly performant Pyrocko functions implemented in C language. The inference is using PyTorch which enables GPU computation of the seismic imaging functions.</p> <p>This enables high throughput of seismic data in different scenarios.</p> Number Stations Throughput in MB Throughput in Waveform data 300+ 50 MB/sec 12 hours/sec 50 200 MB/sec 6 hours/sec <p>Scanning a 600 GB (~700 years of waveforms) data set costs ~2 days on a 64 cores machine equipped with an Nvidia A100 GPU.</p> <p>Note</p> <p>The performance depends heavily on the octree resolution and the number of events detected in the data set.</p>"},{"location":"benchmark/#related-projects","title":"Related Projects","text":"<p>A list of other projects using stacking and migration approach to back-project seismic energy sources in 3D space:</p>"},{"location":"benchmark/#lassie-v1","title":"Lassie-v1","text":"<p>Lassie - The friendly Earthquake detector in version 1. Qseek utilizes the same optimized heavy-duty functions for stacking and migration as Lassie v1.</p> <p>Lassie-v1 on Pyrocko Git</p>"},{"location":"benchmark/#quakemigrate","title":"QuakeMigrate","text":"<p>QuakeMigrate uses a waveform migration and stacking algorithm to search for coherent seismic phase arrivals across a network of instruments. It produces\u2014from raw data\u2014catalogues of earthquakes with locations, origin times, phase arrival picks, and local magnitude estimates, as well as rigorous estimates of the associated uncertainties.</p> <p>QuakeMigrate on GitHub</p>"},{"location":"benchmark/#bpmf","title":"BPMF","text":"<p>Complete framework for earthquake detection and location: Backprojection and matched-filtering (BPMF), with methods for automatic picking, relocation and efficient waveform stacking.</p> <p>BPMF on GitHub</p>"},{"location":"benchmark/#loki","title":"Loki","text":"<p>LOKI (LOcation of seismic events through traveltime staKIng) is a code that performs earthquake detection and location using waveform coherence analysis (waveform stacking).</p> <p>Loki on GitHub</p>"},{"location":"benchmark/#malmi","title":"MALMI","text":"<p>MALMI (MAchine Learning aided earthquake MIgration location), variant of Loki for detecting and locating earthquakes using ML image functions provided by SeisBench.</p> <p>MALMI on GitHub</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>The installation is straight-forward using pip or pipx.</p> From GitHub<pre><code>pip install git+https://github.com/pyrocko/qseek\n</code></pre> From GitHub the Development Branch<pre><code>pip install git+https://github.com/pyrocko/qseek@dev\n</code></pre> <p>or</p> Using pipx<pre><code>pipx install git+https://github.com/pyrocko/qseek\n</code></pre>"},{"location":"getting_started/#running-qseek","title":"Running Qseek","text":"<p>The main entry point in the executeable is the <code>qseek</code> command. The provided command line interface (CLI) and a JSON config file is all what is needed to run the program.</p> <pre><code>qseek --help\n</code></pre> <pre><code>usage: qseek [-h] [--verbose] [--version]\n             {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas}\n             ...\n\nqseek - The wholesome earthquake detector \ud83d\ude80\n\noptions:\n  -h, --help            show this help message and exit\n  --verbose, -v         increase verbosity of the log messages, repeat to\n                        increase. Default level is INFO\n  --version             show version and exit\n\ncommands:\n  Available commands to run qseek. Get command help with `qseek &lt;command&gt;\n  --help`.\n\n  {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas}\n    config              print a new config\n    search              start a search\n    continue            continue an existing search\n    snuffler            start the Pyrocko snuffler to inspect waveforms,\n                        events and picks\n    feature-extraction  extract features from an existing run\n    modules             show available modules\n    serve               start webserver and serve results from an existing run\n    export              export detections to different output formats\n    clear-cache         clear the cach directory\n    dump-schemas        dump data models to json-schema (development)\n</code></pre>"},{"location":"getting_started/#initializing-a-new-project","title":"Initializing a New Project","text":"<p>Once installed you can run the <code>qseek</code> executeable to initialize a new project.</p> Initialize new Project<pre><code>qseek config &gt; my-search.json\n</code></pre> <p>Check out the <code>my-search.json</code> config file and add your waveform data and velocity models.</p> Minimal Configuration Example <p>Here is a minimal JSON configuration for Qseek. <pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": [],\n    \"max_distance\": null\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"channel_selector\": null,\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [\n      \"data\"\n    ],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"n_threads\": 8,\n    \"watch_waveforms\": false,\n    \"queue_size\": 16\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"sampling_rate\": 100.0,\n      \"phase_map\": {\n        \"P\": \"cake:P\",\n        \"S\": \"cake:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      }\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    },\n    {\n      \"tracer\": \"FastMarching\",\n      \"velocity_model\": {\n        \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      },\n      \"interpolation_method\": \"linear\",\n      \"nthreads\": 0,\n      \"implementation\": \"scikit-fmm\",\n      \"phases\": [\n        \"fm:P\",\n        \"fm:S\"\n      ]\n    }\n  ],\n  \"distance_weights\": {\n    \"shape\": \"exponential\",\n    \"exponent\": 2.0,\n    \"radius_meters\": \"mean_interstation\",\n    \"waterlevel\": 0.0,\n    \"normalize\": true\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": \"MAD\",\n  \"pick_confidence_threshold\": 0.2,\n  \"min_stations\": 3,\n  \"ignore_boundary\": false,\n  \"ignore_boundary_width\": \"root_node_size\",\n  \"node_interpolation\": true,\n  \"detection_blinding\": \"PT1S\",\n  \"power_mean\": 1.0,\n  \"window_length\": \"PT5M\",\n  \"n_threads_parstack\": \"auto\",\n  \"n_threads_argmax\": \"auto\",\n  \"save_images\": false,\n  \"created\": \"2025-10-01T16:09:46.897673Z\"\n}\n</code></pre></p> <p>For more details and information about the component, head over to details of the modules.</p>"},{"location":"getting_started/#starting-the-search","title":"Starting the Search","text":"<p>Once happy with the configuration, start the <code>qseek</code> CLI.</p> Start the earthquake detection and localization<pre><code>qseek search my-search.json\n</code></pre>"},{"location":"visualizing_results/","title":"Visualizing Detections","text":"<p>The event detections are exported in Qseek-native JSON, Pyrocko YAML format and as CSV files.</p>"},{"location":"visualizing_results/#pyrocko-sparrow","title":"Pyrocko Sparrow","text":"<p>For large data sets use the Pyrocko Sparrow to visualise seismic event detections in 3D. Also seismic stations and many other features from the Pyrocko ecosystem can be integrated into the view.</p> <p></p>"},{"location":"visualizing_results/#qgis","title":"QGIS","text":"<p>QGIS can be used to import <code>.csv</code> and explore the data in an interactive fashion. Detections can be rendered by e.g. the detection semblance or the calculated magnitude.</p> <p></p>"},{"location":"api/models/","title":"Models","text":""},{"location":"api/models/#qseek.models.location.Location","title":"qseek.models.location.Location  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>lat</code>                 (<code>float</code>)             </li> <li> <code>lon</code>                 (<code>float</code>)             </li> <li> <code>east_shift</code>                 (<code>float</code>)             </li> <li> <code>north_shift</code>                 (<code>float</code>)             </li> <li> <code>elevation</code>                 (<code>float</code>)             </li> <li> <code>depth</code>                 (<code>float</code>)             </li> <li> <code>_cached_lat_lon</code>                 (<code>tuple[float, float] | None</code>)             </li> <li> <code>_cached_origin</code>                 (<code>Location | None</code>)             </li> </ul>"},{"location":"api/models/#qseek.models.location.Location.depth","title":"depth  <code>pydantic-field</code>","text":"<pre><code>depth: float = 0.0\n</code></pre> <p>Depth in meters, positive is down.</p>"},{"location":"api/models/#qseek.models.location.Location.east_shift","title":"east_shift  <code>pydantic-field</code>","text":"<pre><code>east_shift: float = 0.0\n</code></pre> <p>East shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.location.Location.effective_lat_lon","title":"effective_lat_lon  <code>property</code>","text":"<pre><code>effective_lat_lon: tuple[float, float]\n</code></pre> <p>Shift-corrected lat/lon pair of the location.</p>"},{"location":"api/models/#qseek.models.location.Location.elevation","title":"elevation  <code>pydantic-field</code>","text":"<pre><code>elevation: float = 0.0\n</code></pre> <p>Elevation in meters.</p>"},{"location":"api/models/#qseek.models.location.Location.lat","title":"lat  <code>pydantic-field</code>","text":"<pre><code>lat: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/models/#qseek.models.location.Location.lon","title":"lon  <code>pydantic-field</code>","text":"<pre><code>lon: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/models/#qseek.models.location.Location.north_shift","title":"north_shift  <code>pydantic-field</code>","text":"<pre><code>north_shift: float = 0.0\n</code></pre> <p>North shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.location.Location.as_wkt","title":"as_wkt","text":"<pre><code>as_wkt() -&gt; str\n</code></pre> <p>Return the location as WKT string.</p>"},{"location":"api/models/#qseek.models.location.Location.azimuth_to","title":"azimuth_to","text":"<pre><code>azimuth_to(other: Location) -&gt; float\n</code></pre> <p>Compute azimuth [\u00b0] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The azimuth in [\u00b0].</p>"},{"location":"api/models/#qseek.models.location.Location.distance_to","title":"distance_to","text":"<pre><code>distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute 3-dimensional distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance in [m].</p>"},{"location":"api/models/#qseek.models.location.Location.offset_from","title":"offset_from","text":"<pre><code>offset_from(other: Location) -&gt; tuple[float, float, float]\n</code></pre> <p>Return offset vector (east, north, depth) from other location in [m].</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The offset vector.</p>"},{"location":"api/models/#qseek.models.location.Location.origin","title":"origin","text":"<pre><code>origin() -&gt; Location\n</code></pre> <p>Get the origin location.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>The origin location.</p>"},{"location":"api/models/#qseek.models.location.Location.shift","title":"shift","text":"<pre><code>shift(east: float, north: float, elevation: float) -&gt; Self\n</code></pre> <p>Shift the location by the given offsets.</p> <p>Parameters:</p> Name Type Description Default <code>east</code> <code>float</code> <p>East offset in [m].</p> required <code>north</code> <code>float</code> <p>North offset in [m].</p> required <code>elevation</code> <code>float</code> <p>Elevation offset in [m].</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.location.Location.shifted_origin","title":"shifted_origin","text":"<pre><code>shifted_origin() -&gt; Self\n</code></pre> <p>Shift the origin of the location to the effective lat/lon.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.location.Location.surface_distance_to","title":"surface_distance_to","text":"<pre><code>surface_distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute surface distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The surface distance in [m].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection","title":"qseek.models.detection.EventDetection  <code>pydantic-model</code>","text":"<p>               Bases: <code>Location</code></p> <p>Fields:</p> <ul> <li> <code>lat</code>                 (<code>float</code>)             </li> <li> <code>lon</code>                 (<code>float</code>)             </li> <li> <code>east_shift</code>                 (<code>float</code>)             </li> <li> <code>north_shift</code>                 (<code>float</code>)             </li> <li> <code>elevation</code>                 (<code>float</code>)             </li> <li> <code>depth</code>                 (<code>float</code>)             </li> <li> <code>_cached_lat_lon</code>                 (<code>tuple[float, float] | None</code>)             </li> <li> <code>_cached_origin</code>                 (<code>Location | None</code>)             </li> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>time</code>                 (<code>AwareDatetime</code>)             </li> <li> <code>semblance</code>                 (<code>PositiveFloat</code>)             </li> <li> <code>n_stations</code>                 (<code>int</code>)             </li> <li> <code>distance_border</code>                 (<code>PositiveFloat</code>)             </li> <li> <code>in_bounds</code>                 (<code>bool</code>)             </li> <li> <code>uncertainty</code>                 (<code>DetectionUncertainty | None</code>)             </li> <li> <code>magnitudes</code>                 (<code>list[EventMagnitudeType]</code>)             </li> <li> <code>features</code>                 (<code>list[EventFeaturesType]</code>)             </li> <li> <code>_receivers</code>                 (<code>EventReceivers | None</code>)             </li> <li> <code>_detection_idx</code>                 (<code>int | None</code>)             </li> <li> <code>_receiver_cache</code>                 (<code>ReceiverCache | None</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>migrate_features</code>                 \u2192                   <code>features</code> </li> </ul>"},{"location":"api/models/#qseek.models.detection.EventDetection.depth","title":"depth  <code>pydantic-field</code>","text":"<pre><code>depth: float = 0.0\n</code></pre> <p>Depth in meters, positive is down.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.distance_border","title":"distance_border  <code>pydantic-field</code>","text":"<pre><code>distance_border: PositiveFloat\n</code></pre> <p>Distance to the nearest border in meters. Only distance to NW, SW and bottom border is considered.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.east_shift","title":"east_shift  <code>pydantic-field</code>","text":"<pre><code>east_shift: float = 0.0\n</code></pre> <p>East shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.effective_lat_lon","title":"effective_lat_lon  <code>property</code>","text":"<pre><code>effective_lat_lon: tuple[float, float]\n</code></pre> <p>Shift-corrected lat/lon pair of the location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.elevation","title":"elevation  <code>pydantic-field</code>","text":"<pre><code>elevation: float = 0.0\n</code></pre> <p>Elevation in meters.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.features","title":"features  <code>pydantic-field</code>","text":"<pre><code>features: list[EventFeaturesType] = []\n</code></pre> <p>Event features.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.in_bounds","title":"in_bounds  <code>pydantic-field</code>","text":"<pre><code>in_bounds: bool = True\n</code></pre> <p>Is detection in bounds, and inside the configured border.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.lat","title":"lat  <code>pydantic-field</code>","text":"<pre><code>lat: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.lon","title":"lon  <code>pydantic-field</code>","text":"<pre><code>lon: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.magnitude","title":"magnitude  <code>property</code>","text":"<pre><code>magnitude: EventMagnitude | None\n</code></pre> <p>Returns the magnitude of the event.</p> <p>If there are no magnitudes available, returns None.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.magnitudes","title":"magnitudes  <code>pydantic-field</code>","text":"<pre><code>magnitudes: list[EventMagnitudeType] = []\n</code></pre> <p>Event magnitudes.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.n_picks","title":"n_picks  <code>property</code>","text":"<pre><code>n_picks: int\n</code></pre> <p>Number of phase picks in the detection.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.n_stations","title":"n_stations  <code>pydantic-field</code>","text":"<pre><code>n_stations: int = 0\n</code></pre> <p>Number of stations in the detection.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.north_shift","title":"north_shift  <code>pydantic-field</code>","text":"<pre><code>north_shift: float = 0.0\n</code></pre> <p>North shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.receivers","title":"receivers  <code>property</code>","text":"<pre><code>receivers: EventReceivers\n</code></pre> <p>Retrieves the event receivers associated with the detection.</p> <p>Returns:</p> Name Type Description <code>EventReceivers</code> <code>EventReceivers</code> <p>The event receivers associated with the detection.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the receivers cannot be fetched without a set rundir and detection index.</p> <code>ValueError</code> <p>If the receivers cannot be fetched due to missing rundir and index, or if there is a UID mismatch between the fetched receivers and the detection.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.semblance","title":"semblance  <code>pydantic-field</code>","text":"<pre><code>semblance: PositiveFloat\n</code></pre> <p>Detection semblance</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.time","title":"time  <code>pydantic-field</code>","text":"<pre><code>time: AwareDatetime\n</code></pre> <p>Detection time</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.uncertainty","title":"uncertainty  <code>pydantic-field</code>","text":"<pre><code>uncertainty: DetectionUncertainty | None = None\n</code></pre> <p>Detection uncertainty.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.add_feature","title":"add_feature","text":"<pre><code>add_feature(feature: EventFeature) -&gt; None\n</code></pre> <p>Add feature to the feature set.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>EventFeature</code> <p>Feature to add</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.add_magnitude","title":"add_magnitude","text":"<pre><code>add_magnitude(magnitude: EventMagnitude) -&gt; None\n</code></pre> <p>Add magnitude to detection.</p> <p>Parameters:</p> Name Type Description Default <code>magnitude</code> <code>EventMagnitudeType</code> <p>magnitude</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.as_pyrocko_event","title":"as_pyrocko_event","text":"<pre><code>as_pyrocko_event() -&gt; Event\n</code></pre> <p>Get detection as Pyrocko event.</p> <p>Returns:</p> Name Type Description <code>Event</code> <code>Event</code> <p>Pyrocko event</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.as_wkt","title":"as_wkt","text":"<pre><code>as_wkt() -&gt; str\n</code></pre> <p>Return the location as WKT string.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.azimuth_to","title":"azimuth_to","text":"<pre><code>azimuth_to(other: Location) -&gt; float\n</code></pre> <p>Compute azimuth [\u00b0] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The azimuth in [\u00b0].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.distance_to","title":"distance_to","text":"<pre><code>distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute 3-dimensional distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance in [m].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.export_csv_line","title":"export_csv_line","text":"<pre><code>export_csv_line(file: Path, jitter_location: float = 0.0) -&gt; None\n</code></pre> <p>Save the detection as a CSV line.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>jitter_location</code> <code>float</code> <p>The amount of spatial jitter to apply. Defaults to 0.0.</p> <code>0.0</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.export_pyrocko_event","title":"export_pyrocko_event","text":"<pre><code>export_pyrocko_event(file: Path, jitter_location: float = 0.0) -&gt; None\n</code></pre> <p>Write the detection as a Pyrocko event to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the output file.</p> required <code>jitter_location</code> <code>float</code> <p>The amount of spatial jitter to apply. Defaults to 0.0.</p> <code>0.0</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.export_pyrocko_markers","title":"export_pyrocko_markers","text":"<pre><code>export_pyrocko_markers(filename: Path) -&gt; None\n</code></pre> <p>Save detection's Pyrocko markers to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path to marker file</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.get_azimuthal_coverage","title":"get_azimuthal_coverage","text":"<pre><code>get_azimuthal_coverage(observed_only: bool = True) -&gt; float\n</code></pre> <p>Get azimuthal coverage of the detection.</p> <p>This is the reverse of the azimuthal gap: <code>360 - azimuthal_gap</code>.</p> <p>Parameters:</p> Name Type Description Default <code>observed_only</code> <code>bool</code> <p>Consider only observed azimuths. Defaults to True.</p> <code>True</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_azimuthal_gap","title":"get_azimuthal_gap","text":"<pre><code>get_azimuthal_gap(observed_only: bool = True) -&gt; float\n</code></pre> <p>Get maximum azimuthal gap of the detection.</p> <p>Parameters:</p> Name Type Description Default <code>observed_only</code> <code>bool</code> <p>Consider only observed azimuths. Defaults to True.</p> <code>True</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_csv_dict","title":"get_csv_dict","text":"<pre><code>get_csv_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get detection as CSV line.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: CSV line</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_pyrocko_markers","title":"get_pyrocko_markers","text":"<pre><code>get_pyrocko_markers(modelled: bool = True, observed: bool = True) -&gt; list[EventMarker | PhaseMarker]\n</code></pre> <p>Get detections as Pyrocko markers.</p> <p>Parameters:</p> Name Type Description Default <code>modelled</code> <code>bool</code> <p>Include modelled arrivals. Defaults to True.</p> <code>True</code> <code>observed</code> <code>bool</code> <p>Include observed arrivals. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[EventMarker | PhaseMarker]</code> <p>list[marker.EventMarker | marker.PhaseMarker]: Pyrocko markers</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_receiver_azimuths","title":"get_receiver_azimuths","text":"<pre><code>get_receiver_azimuths(observed_only: bool = True)\n</code></pre> <p>Get receiver azimuths.</p> <p>Parameters:</p> Name Type Description Default <code>observed_only</code> <code>bool</code> <p>Return only observed azimuths. Defaults to False.</p> <code>True</code> <p>Returns:</p> Type Description <p>dict[str, float]: Receiver azimuths</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.jitter_location","title":"jitter_location","text":"<pre><code>jitter_location(meters: float) -&gt; Self\n</code></pre> <p>Randomize detection location.</p> <p>Parameters:</p> Name Type Description Default <code>meters</code> <code>float</code> <p>maximum randomization in meters</p> required <p>Returns:</p> Name Type Description <code>EventDetection</code> <code>Self</code> <p>spatially jittered detection</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.offset_from","title":"offset_from","text":"<pre><code>offset_from(other: Location) -&gt; tuple[float, float, float]\n</code></pre> <p>Return offset vector (east, north, depth) from other location in [m].</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The offset vector.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.origin","title":"origin","text":"<pre><code>origin() -&gt; Location\n</code></pre> <p>Get the origin location.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>The origin location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.save","title":"save  <code>async</code>","text":"<pre><code>save(rundir: Path, update: bool = False, jitter_location: float = 0.0) -&gt; None\n</code></pre> <p>Dump the detection data to a file.</p> <p>After the detection is dumped, the receivers are dumped to a separate file and the receivers cache is cleared.</p> <p>Parameters:</p> Name Type Description Default <code>rundir</code> <code>Path</code> <p>The path to the rundir.</p> required <code>update</code> <code>bool</code> <p>Whether to update an existing detection or append a new one.</p> <code>False</code> <code>jitter_location</code> <code>float</code> <p>The amount of spatial jitter to apply to the exported detection. Defaults to 0.0.</p> <code>0.0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the detection index is not set and update is True.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.set_index","title":"set_index","text":"<pre><code>set_index(index: int, force: bool = False) -&gt; None\n</code></pre> <p>Set the index of the detection.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to set.</p> required <code>force</code> <code>bool</code> <p>Whether to force the index to be set. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.set_receiver_cache","title":"set_receiver_cache","text":"<pre><code>set_receiver_cache(rundir: Path) -&gt; None\n</code></pre> <p>Set the rundir for the detection model.</p> <p>Parameters:</p> Name Type Description Default <code>rundir</code> <code>Path</code> <p>The path to the rundir.</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.set_uncertainty","title":"set_uncertainty","text":"<pre><code>set_uncertainty(uncertainty: DetectionUncertainty) -&gt; None\n</code></pre> <p>Set detection uncertainty.</p> <p>Parameters:</p> Name Type Description Default <code>uncertainty</code> <code>DetectionUncertainty</code> <p>detection uncertainty</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.shift","title":"shift","text":"<pre><code>shift(east: float, north: float, elevation: float) -&gt; Self\n</code></pre> <p>Shift the location by the given offsets.</p> <p>Parameters:</p> Name Type Description Default <code>east</code> <code>float</code> <p>East offset in [m].</p> required <code>north</code> <code>float</code> <p>North offset in [m].</p> required <code>elevation</code> <code>float</code> <p>Elevation offset in [m].</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.shifted_origin","title":"shifted_origin","text":"<pre><code>shifted_origin() -&gt; Self\n</code></pre> <p>Shift the origin of the location to the effective lat/lon.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.snuffle","title":"snuffle","text":"<pre><code>snuffle(squirrel: Squirrel, restituted: bool | MeasurementUnit = False) -&gt; None\n</code></pre> <p>Open snuffler for detection.</p> <p>Parameters:</p> Name Type Description Default <code>squirrel</code> <code>Squirrel</code> <p>The squirrel, holding the data</p> required <code>restituted</code> <code>bool</code> <p>Restitude the data. Defaults to False.</p> <code>False</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.surface_distance_to","title":"surface_distance_to","text":"<pre><code>surface_distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute surface distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The surface distance in [m].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.update","title":"update  <code>async</code>","text":"<pre><code>update(rundir: Path) -&gt; None\n</code></pre> <p>Update detection in database.</p> <p>Doing this often requires a lot of I/O.</p>"},{"location":"api/octree/","title":"Octree","text":""},{"location":"api/octree/#qseek.octree.Octree","title":"qseek.octree.Octree  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Iterator[Node]</code></p> <p>Config:</p> <ul> <li><code>ignored_types</code>: <code>(cached_property,)</code></li> </ul> <p>Fields:</p> <ul> <li> <code>location</code>                 (<code>Location</code>)             </li> <li> <code>root_node_size</code>                 (<code>PositiveFloat</code>)             </li> <li> <code>n_levels</code>                 (<code>int</code>)             </li> <li> <code>east_bounds</code>                 (<code>Range</code>)             </li> <li> <code>north_bounds</code>                 (<code>Range</code>)             </li> <li> <code>depth_bounds</code>                 (<code>Range</code>)             </li> <li> <code>_root_nodes</code>                 (<code>list[Node]</code>)             </li> <li> <code>_semblance</code>                 (<code>ndarray | None</code>)             </li> <li> <code>_cached_coordinates</code>                 (<code>dict[CoordSystem, ndarray]</code>)             </li> <li> <code>_nodes</code>                 (<code>list[Node]</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>check_reference</code>                 \u2192                   <code>location</code> </li> <li> <code>check_limits</code> </li> </ul>"},{"location":"api/octree/#qseek.octree.Octree.depth_bounds","title":"depth_bounds  <code>pydantic-field</code>","text":"<pre><code>depth_bounds: Range = Range(0 * KM, 20 * KM)\n</code></pre> <p>Depth bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.east_bounds","title":"east_bounds  <code>pydantic-field</code>","text":"<pre><code>east_bounds: Range = Range(-10 * KM, 10 * KM)\n</code></pre> <p>East bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.effective_depth_bounds","title":"effective_depth_bounds  <code>property</code>","text":"<pre><code>effective_depth_bounds: Range\n</code></pre> <p>Effective depth bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.leaf_nodes","title":"leaf_nodes  <code>cached</code> <code>property</code>","text":"<pre><code>leaf_nodes: list[Node]\n</code></pre> <p>Get all leaf nodes of the octree.</p> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of leaf nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.location","title":"location  <code>pydantic-field</code>","text":"<pre><code>location: Location = Location(lat=0.0, lon=0.0)\n</code></pre> <p>The geographical center of the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.n_leaf_nodes","title":"n_leaf_nodes  <code>cached</code> <code>property</code>","text":"<pre><code>n_leaf_nodes: int\n</code></pre> <p>Number of nodes in the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.n_levels","title":"n_levels  <code>pydantic-field</code>","text":"<pre><code>n_levels: int = 5\n</code></pre> <p>Number of levels in the octree, defining the final resolution of the detection. Default is 5.</p>"},{"location":"api/octree/#qseek.octree.Octree.n_nodes","title":"n_nodes  <code>cached</code> <code>property</code>","text":"<pre><code>n_nodes: int\n</code></pre> <p>Number of nodes in the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes: list[Node]\n</code></pre> <p>List of nodes in the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.north_bounds","title":"north_bounds  <code>pydantic-field</code>","text":"<pre><code>north_bounds: Range = Range(-10 * KM, 10 * KM)\n</code></pre> <p>North bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.root_node_size","title":"root_node_size  <code>pydantic-field</code>","text":"<pre><code>root_node_size: PositiveFloat = 1 * KM\n</code></pre> <p>Size of the root node at the initial level (level 0) in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.semblance","title":"semblance  <code>property</code>","text":"<pre><code>semblance: ndarray\n</code></pre> <p>Returns the semblance values of all nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.volume","title":"volume  <code>property</code>","text":"<pre><code>volume: float\n</code></pre> <p>Volume of the octree in cubic meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.cached_bottom","title":"cached_bottom","text":"<pre><code>cached_bottom() -&gt; Self\n</code></pre> <p>Returns a copy of the octree refined to the cached bottom nodes.</p> <p>Raises:</p> Type Description <code>EnvironmentError</code> <p>If the octree has never been split.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Copy of the octree with cached bottom nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.check_limits","title":"check_limits  <code>pydantic-validator</code>","text":"<pre><code>check_limits() -&gt; Octree\n</code></pre> <p>Check that the size limits are valid.</p>"},{"location":"api/octree/#qseek.octree.Octree.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear the octree's cached data.</p>"},{"location":"api/octree/#qseek.octree.Octree.distances_stations","title":"distances_stations","text":"<pre><code>distances_stations(stations: Stations) -&gt; ndarray\n</code></pre> <p>Returns the 3D distances from all nodes to all stations.</p> <p>Parameters:</p> Name Type Description Default <code>stations</code> <code>Stations</code> <p>Stations to calculate distance to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Of shape (n-nodes, n-stations).</p>"},{"location":"api/octree/#qseek.octree.Octree.distances_stations_surface","title":"distances_stations_surface","text":"<pre><code>distances_stations_surface(stations: Stations) -&gt; ndarray\n</code></pre> <p>Returns the surface distance from all nodes to all stations.</p> <p>Parameters:</p> Name Type Description Default <code>stations</code> <code>Stations</code> <p>Stations to calculate distance to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Distances in shape (n-nodes, n-stations).</p>"},{"location":"api/octree/#qseek.octree.Octree.extent","title":"extent","text":"<pre><code>extent() -&gt; tuple[float, float, float]\n</code></pre> <p>Returns the extent of the octree.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: EW, NS and depth extent of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_corners","title":"get_corners","text":"<pre><code>get_corners() -&gt; list[Location]\n</code></pre> <p>Get the corners of the octree.</p> <p>Returns:</p> Type Description <code>list[Location]</code> <p>list[Location]: List of locations.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_node_size","title":"get_node_size","text":"<pre><code>get_node_size(level: int = 0) -&gt; float\n</code></pre> <p>Get the size of a node at a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to get node size from.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size of the node.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes(indices: Iterable[int]) -&gt; list[Node]\n</code></pre> <p>Retrieves a list of nodes from the octree based on the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Iterable[int]</code> <p>The indices of the nodes to retrieve.</p> required <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: A list of nodes corresponding to the given indices.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_nodes_by_threshold","title":"get_nodes_by_threshold","text":"<pre><code>get_nodes_by_threshold(semblance_threshold: float = 0.0) -&gt; list[Node]\n</code></pre> <p>Get all nodes with a semblance above a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>semblance_threshold</code> <code>float</code> <p>Semblance threshold. Default is 0.0.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_nodes_level","title":"get_nodes_level","text":"<pre><code>get_nodes_level(level: int = 0) -&gt; list[Node]\n</code></pre> <p>Get all nodes at a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to get nodes from.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.interpolate_max_semblance","title":"interpolate_max_semblance  <code>async</code>","text":"<pre><code>interpolate_max_semblance(peak_node: Node) -&gt; Location\n</code></pre> <p>Interpolate the location of the maximum semblance value.</p> <p>This method calculates the location of the maximum semblance value by performing interpolation using surrounding nodes. It uses the scipy Rbf (Radial basis function) interpolation method to fit a smooth function to the given data points. The function is then minimized to find the location of the maximum value.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>Location of the maximum semblance value.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If no semblance values are set.</p>"},{"location":"api/octree/#qseek.octree.Octree.map_semblance","title":"map_semblance","text":"<pre><code>map_semblance(semblance: ndarray, leaf_only: bool = True) -&gt; None\n</code></pre> <p>Maps semblance values to nodes.</p> <p>Parameters:</p> Name Type Description Default <code>semblance</code> <code>ndarray</code> <p>Of shape (n-nodes,).</p> required <code>leaf_only</code> <code>bool</code> <p>If True, only leaf nodes are mapped. Defaults to True.</p> <code>True</code>"},{"location":"api/octree/#qseek.octree.Octree.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Initialize octree. This method is called by the pydantic model.</p>"},{"location":"api/octree/#qseek.octree.Octree.reduce_axis","title":"reduce_axis","text":"<pre><code>reduce_axis(surface: Literal['NE', 'ED', 'ND'] = 'NE', max_level: int = -1, accumulator: Callable[ndarray] = max) -&gt; ndarray\n</code></pre> <p>Reduce the octree's nodes to the surface.</p> <p>Parameters:</p> Name Type Description Default <code>surface</code> <code>Literal['NE', 'ED', 'ND']</code> <p>Surface to reduce to. Defaults to \"NE\".</p> <code>'NE'</code> <code>max_level</code> <code>int</code> <p>Maximum level to reduce to. Defaults to -1.</p> <code>-1</code> <code>accumulator</code> <code>Callable</code> <p>Accumulator function. Defaults to np.max.</p> <code>max</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Of shape (n-nodes, 4) with columns (east, north, depth, value).</p>"},{"location":"api/octree/#qseek.octree.Octree.reset","title":"reset","text":"<pre><code>reset() -&gt; Self\n</code></pre> <p>Reset the octree to its initial state and return it.</p>"},{"location":"api/octree/#qseek.octree.Octree.save_pickle","title":"save_pickle","text":"<pre><code>save_pickle(filename: Path) -&gt; None\n</code></pre> <p>Save the octree to a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Filename to save to.</p> required"},{"location":"api/octree/#qseek.octree.Octree.set_level","title":"set_level","text":"<pre><code>set_level(level: int) -&gt; None\n</code></pre> <p>Set the octree to a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to set the octree to.</p> required"},{"location":"api/octree/#qseek.octree.Octree.smallest_node_size","title":"smallest_node_size","text":"<pre><code>smallest_node_size() -&gt; float\n</code></pre> <p>Returns the smallest possible node size.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Smallest possible node size.</p>"},{"location":"api/octree/#qseek.octree.Octree.total_number_nodes","title":"total_number_nodes","text":"<pre><code>total_number_nodes() -&gt; int\n</code></pre> <p>Returns the total number of nodes of all levels.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of nodes.</p>"},{"location":"api/overview/","title":"API Overview","text":"<p>The following pages give an overview of the Python API.</p>"},{"location":"api/ray_tracer/","title":"Ray Tracers","text":""},{"location":"api/ray_tracer/#qseek.tracers.base.RayTracer","title":"qseek.tracers.base.RayTracer  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>tracer</code>                 (<code>Literal['RayTracer']</code>)             </li> </ul>"},{"location":"api/ray_tracer/#qseek.tracers.base.RayTracer.get_travel_times","title":"get_travel_times  <code>async</code>","text":"<pre><code>get_travel_times(phase: str, nodes: Sequence[Node], stations: Stations) -&gt; ndarray\n</code></pre> <p>Get travel times for a phase from a source to a set of stations.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>str</code> <p>Phase name.</p> required <code>nodes</code> <code>Sequence[Node]</code> <p>Nodes to get traveltime for.</p> required <code>stations</code> <code>Stations</code> <p>Stations to calculate travel times to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Travel times in seconds.</p>"},{"location":"api/stations/","title":"Station Inventory","text":""},{"location":"api/stations/#qseek.models.station.Station","title":"qseek.models.station.Station  <code>pydantic-model</code>","text":"<p>               Bases: <code>Location</code></p> <p>Fields:</p> <ul> <li> <code>lat</code>                 (<code>float</code>)             </li> <li> <code>lon</code>                 (<code>float</code>)             </li> <li> <code>east_shift</code>                 (<code>float</code>)             </li> <li> <code>north_shift</code>                 (<code>float</code>)             </li> <li> <code>elevation</code>                 (<code>float</code>)             </li> <li> <code>depth</code>                 (<code>float</code>)             </li> <li> <code>_cached_lat_lon</code>                 (<code>tuple[float, float] | None</code>)             </li> <li> <code>_cached_origin</code>                 (<code>Location | None</code>)             </li> <li> <code>network</code>                 (<code>str</code>)             </li> <li> <code>station</code>                 (<code>str</code>)             </li> <li> <code>location</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/stations/#qseek.models.station.Station.depth","title":"depth  <code>pydantic-field</code>","text":"<pre><code>depth: float = 0.0\n</code></pre> <p>Depth in meters, positive is down.</p>"},{"location":"api/stations/#qseek.models.station.Station.east_shift","title":"east_shift  <code>pydantic-field</code>","text":"<pre><code>east_shift: float = 0.0\n</code></pre> <p>East shift towards geographical reference in meters.</p>"},{"location":"api/stations/#qseek.models.station.Station.effective_lat_lon","title":"effective_lat_lon  <code>property</code>","text":"<pre><code>effective_lat_lon: tuple[float, float]\n</code></pre> <p>Shift-corrected lat/lon pair of the location.</p>"},{"location":"api/stations/#qseek.models.station.Station.elevation","title":"elevation  <code>pydantic-field</code>","text":"<pre><code>elevation: float = 0.0\n</code></pre> <p>Elevation in meters.</p>"},{"location":"api/stations/#qseek.models.station.Station.lat","title":"lat  <code>pydantic-field</code>","text":"<pre><code>lat: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/stations/#qseek.models.station.Station.lon","title":"lon  <code>pydantic-field</code>","text":"<pre><code>lon: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/stations/#qseek.models.station.Station.north_shift","title":"north_shift  <code>pydantic-field</code>","text":"<pre><code>north_shift: float = 0.0\n</code></pre> <p>North shift towards geographical reference in meters.</p>"},{"location":"api/stations/#qseek.models.station.Station.nsl","title":"nsl  <code>property</code>","text":"<pre><code>nsl: _NSL\n</code></pre> <p>Network Station Location code as tuple.</p> <p>Returns:</p> Type Description <code>_NSL</code> <p>tuple[str, str, str]: Network, Station, Location</p>"},{"location":"api/stations/#qseek.models.station.Station.as_wkt","title":"as_wkt","text":"<pre><code>as_wkt() -&gt; str\n</code></pre> <p>Return the location as WKT string.</p>"},{"location":"api/stations/#qseek.models.station.Station.azimuth_to","title":"azimuth_to","text":"<pre><code>azimuth_to(other: Location) -&gt; float\n</code></pre> <p>Compute azimuth [\u00b0] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The azimuth in [\u00b0].</p>"},{"location":"api/stations/#qseek.models.station.Station.distance_to","title":"distance_to","text":"<pre><code>distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute 3-dimensional distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance in [m].</p>"},{"location":"api/stations/#qseek.models.station.Station.offset_from","title":"offset_from","text":"<pre><code>offset_from(other: Location) -&gt; tuple[float, float, float]\n</code></pre> <p>Return offset vector (east, north, depth) from other location in [m].</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The offset vector.</p>"},{"location":"api/stations/#qseek.models.station.Station.origin","title":"origin","text":"<pre><code>origin() -&gt; Location\n</code></pre> <p>Get the origin location.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>The origin location.</p>"},{"location":"api/stations/#qseek.models.station.Station.shift","title":"shift","text":"<pre><code>shift(east: float, north: float, elevation: float) -&gt; Self\n</code></pre> <p>Shift the location by the given offsets.</p> <p>Parameters:</p> Name Type Description Default <code>east</code> <code>float</code> <p>East offset in [m].</p> required <code>north</code> <code>float</code> <p>North offset in [m].</p> required <code>elevation</code> <code>float</code> <p>Elevation offset in [m].</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/stations/#qseek.models.station.Station.shifted_origin","title":"shifted_origin","text":"<pre><code>shifted_origin() -&gt; Self\n</code></pre> <p>Shift the origin of the location to the effective lat/lon.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/stations/#qseek.models.station.Station.surface_distance_to","title":"surface_distance_to","text":"<pre><code>surface_distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute surface distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The surface distance in [m].</p>"},{"location":"api/stations/#qseek.models.station.Stations","title":"qseek.models.station.Stations  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>pyrocko_station_yamls</code>                 (<code>list[FilePath]</code>)             </li> <li> <code>station_xmls</code>                 (<code>list[FilePath | DirectoryPath]</code>)             </li> <li> <code>blacklist</code>                 (<code>Blacklist</code>)             </li> <li> <code>stations</code>                 (<code>list[Station]</code>)             </li> <li> <code>max_distance</code>                 (<code>PositiveFloat | None</code>)             </li> </ul>"},{"location":"api/stations/#qseek.models.station.Stations.blacklist","title":"blacklist  <code>pydantic-field</code>","text":"<pre><code>blacklist: Blacklist = Blacklist()\n</code></pre> <p>Blacklist stations and exclude from detecion. Format is <code>['NET.STA.LOC', ...]</code>.</p>"},{"location":"api/stations/#qseek.models.station.Stations.max_distance","title":"max_distance  <code>pydantic-field</code>","text":"<pre><code>max_distance: PositiveFloat | None = None\n</code></pre> <p>Maximum distance in meters from the centroid location to include stations for detection. If None, all stations are included.</p>"},{"location":"api/stations/#qseek.models.station.Stations.n_networks","title":"n_networks  <code>property</code>","text":"<pre><code>n_networks: int\n</code></pre> <p>Number of stations.</p>"},{"location":"api/stations/#qseek.models.station.Stations.n_stations","title":"n_stations  <code>property</code>","text":"<pre><code>n_stations: int\n</code></pre> <p>Number of stations.</p>"},{"location":"api/stations/#qseek.models.station.Stations.pyrocko_station_yamls","title":"pyrocko_station_yamls  <code>pydantic-field</code>","text":"<pre><code>pyrocko_station_yamls: list[FilePath] = []\n</code></pre> <p>List of Pyrocko station YAML files.</p>"},{"location":"api/stations/#qseek.models.station.Stations.station_xmls","title":"station_xmls  <code>pydantic-field</code>","text":"<pre><code>station_xmls: list[FilePath | DirectoryPath] = []\n</code></pre> <p>List of StationXML files or directories containing StationXML (.xml) files.</p>"},{"location":"api/stations/#qseek.models.station.Stations.as_pyrocko_stations","title":"as_pyrocko_stations","text":"<pre><code>as_pyrocko_stations() -&gt; list[Station]\n</code></pre> <p>Convert the stations to PyrockoStation objects.</p> <p>Returns:</p> Type Description <code>list[Station]</code> <p>A list of PyrockoStation objects.</p>"},{"location":"api/stations/#qseek.models.station.Stations.export_csv","title":"export_csv","text":"<pre><code>export_csv(filename: Path) -&gt; None\n</code></pre> <p>Dump stations to CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Path to CSV file.</p> required"},{"location":"api/stations/#qseek.models.station.Stations.export_pyrocko_stations","title":"export_pyrocko_stations","text":"<pre><code>export_pyrocko_stations(filename: Path) -&gt; None\n</code></pre> <p>Dump stations to pyrocko station yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Path to yaml file.</p> required"},{"location":"api/stations/#qseek.models.station.Stations.get_all_nsl","title":"get_all_nsl","text":"<pre><code>get_all_nsl() -&gt; list[NSL]\n</code></pre> <p>Get all NSL codes from all stations.</p>"},{"location":"api/stations/#qseek.models.station.Stations.get_centroid","title":"get_centroid","text":"<pre><code>get_centroid() -&gt; Location\n</code></pre> <p>Get centroid location from all stations.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>Centroid Location.</p>"},{"location":"api/stations/#qseek.models.station.Stations.mean_interstation_distance","title":"mean_interstation_distance","text":"<pre><code>mean_interstation_distance() -&gt; float\n</code></pre> <p>Calculate the mean interstation distance.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean interstation distance in meters.</p>"},{"location":"api/stations/#qseek.models.station.Stations.select_from_traces","title":"select_from_traces","text":"<pre><code>select_from_traces(traces: Iterable[Trace]) -&gt; Stations\n</code></pre> <p>Select stations by NSL code.</p> <p>Stations are not unique and are ordered by the input traces.</p> <p>Parameters:</p> Name Type Description Default <code>traces</code> <code>Iterable[Trace]</code> <p>Iterable of Pyrocko Traces</p> required <p>Returns:</p> Name Type Description <code>Stations</code> <code>Stations</code> <p>Containing only selected stations.</p>"},{"location":"api/stations/#qseek.models.station.Stations.weed_from_nsls","title":"weed_from_nsls","text":"<pre><code>weed_from_nsls(nsls: set[NSL]) -&gt; None\n</code></pre> <p>Remove stations without waveforms from squirrel instances.</p> <p>Parameters:</p> Name Type Description Default <code>nsls</code> <code>list[NSL]</code> <p>List of NSL codes to keep.</p> required"},{"location":"api/stations/#qseek.models.station.Stations.weed_stations","title":"weed_stations","text":"<pre><code>weed_stations() -&gt; None\n</code></pre> <p>Remove stations with bad coordinates or duplicates.</p>"},{"location":"api/utils/","title":"Utils","text":""},{"location":"api/utils/#qseek.utils.Range","title":"qseek.utils.Range  <code>module-attribute</code>","text":"<pre><code>Range = Annotated[_Range, AfterValidator(_range_validator)]\n</code></pre>"},{"location":"api/utils/#qseek.utils._Range","title":"qseek.utils._Range","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Methods:</p> Name Description <code>from_list</code> <p>Create a Range object from a numpy array.</p> <code>inside</code> <p>Check if a value is inside the range.</p> <code>width</code> <p>Calculate the width of the range.</p>"},{"location":"api/utils/#qseek.utils._Range.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(array: ndarray | list[float]) -&gt; _Range\n</code></pre> <p>Create a Range object from a numpy array.</p> <ul> <li>array: numpy.ndarray     The array from which to create the Range object.</li> </ul> <p>Returns: - _Range: The created Range object.</p>"},{"location":"api/utils/#qseek.utils._Range.inside","title":"inside","text":"<pre><code>inside(value: float) -&gt; bool\n</code></pre> <p>Check if a value is inside the range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is inside the range, False otherwise.</p>"},{"location":"api/utils/#qseek.utils._Range.width","title":"width","text":"<pre><code>width() -&gt; float\n</code></pre> <p>Calculate the width of the range.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The width of the range.</p>"},{"location":"components/configuration/","title":"Qseek Configuration","text":"<p>At center is a JSON configuration file which is parsed by Pydantic. The following pages will detail how to setup this JSON file for the search.</p> <p>See the getting started guide for a brief introduction into the CLI.</p> <p>General configuration conventions are outlines in this guide as well.</p> <p>Create a new config file.</p> Using the CLI<pre><code>qseek config\n</code></pre>"},{"location":"components/configuration/#the-search","title":"The Search","text":"<p>The search configuration. This is the entrypoint for the EQ detection and localisation. More information on the submodules (e.g. Octree, Data Provider and other) can be found on subpages in the navigation.</p> <p></p>"},{"location":"components/configuration/#exec-3--search-module","title":"Search Module","text":"Config SearchJSON  <code>stations</code> <p>Station inventory from StationXML or Pyrocko Station YAML.</p> <code>data_provider</code> <p>Data provider for waveform data.</p> <code>pre_processing</code> <p>Pre-processing steps for waveform data.</p> <code>octree</code> <p>Octree volume for the search.</p> <code>image_functions</code> <p>Image functions for waveform processing and phase on-set detection.</p> <code>ray_tracers</code> <p>List of ray tracers for travel time calculation.</p> <code>distance_weights</code> <p>Spatial weights for distance weighting.</p> <code>station_corrections</code> <p>Apply station corrections extracted from a previous run or a path to a directory with station correction files.</p> <code>magnitudes</code> <p>Magnitude calculators to use.</p> <code>features</code> <p>Event features to extract.</p> <code>semblance_sampling_rate</code>: <code>10 | 20 | 25 | 50 | 100 | 200 | 400</code> <p>Sampling rate for the semblance image function. Choose from <code>10, 20, 25, 50, 100, 200 or 400</code> Hz.</p> <code>detection_threshold</code> <p>Detection threshold for semblance.</p> <code>pick_confidence_threshold</code>: <code>0.2</code> <p>Confidence threshold for picking.</p> <code>min_stations</code>: <code>3</code> <p>Minimum number of stations required for detection and localization.</p> <code>ignore_boundary</code>: <code>False | with_surface | without_surface</code> <p>Ignore events that are inside the first root node layer of the octree. If <code>with_surface</code>, all events inside the boundaries of the volume are absorbed. If <code>without_surface</code>, events at the surface are not absorbed.</p> <code>ignore_boundary_width</code> <p>Width of the absorbing boundary around the octree volume. If 'octree' the width is set to the root node size of the octree.</p> <code>node_interpolation</code>: <code>True</code> <p>Interpolate intranode locations for detected events using radial basis functions. If <code>False</code>, the node center location is used for the event hypocentre.</p> <code>detection_blinding</code> <p>Blinding time in seconds before and after the detection peak. This is used to avoid detecting the same event multiple times. Default is 2 seconds.</p> <code>power_mean</code>: <code>1.0</code> <p>Power mean exponent for stacking and combining the image functions for stacking. A value of 1.0 is the arithmetic mean, 2.0 is the quadratic mean. A higher value will result in sharper detections and low values smooth the stacking function.</p> <code>window_length</code> <p>Window length for processing. Smaller window size will be less RAM consuming. Default is 5 minutes.</p> <code>n_threads_parstack</code> <p>Number of threads for stacking and migration. <code>'auto'</code> will use the maximum number of cores and leaves resources for I/O and other work. <code>0</code> uses all available cores.</p> <code>n_threads_argmax</code> <p>Number of threads for argmax. <code>'auto'</code> will use the maximum number of cores and leaves resources for I/O and other work. <code>0</code> uses all available cores.</p> <code>save_images</code>: <code>False</code> <p>Save annotation images to disk for debugging and analysis.</p> JSON for Search<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": [],\n    \"max_distance\": null\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"channel_selector\": null,\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [\n      \"data\"\n    ],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"n_threads\": 8,\n    \"watch_waveforms\": false,\n    \"queue_size\": 16\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"sampling_rate\": 100.0,\n      \"phase_map\": {\n        \"P\": \"cake:P\",\n        \"S\": \"cake:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      }\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    },\n    {\n      \"tracer\": \"FastMarching\",\n      \"velocity_model\": {\n        \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      },\n      \"interpolation_method\": \"linear\",\n      \"nthreads\": 0,\n      \"implementation\": \"scikit-fmm\",\n      \"phases\": [\n        \"fm:P\",\n        \"fm:S\"\n      ]\n    }\n  ],\n  \"distance_weights\": {\n    \"shape\": \"exponential\",\n    \"exponent\": 2.0,\n    \"radius_meters\": \"mean_interstation\",\n    \"waterlevel\": 0.0,\n    \"normalize\": true\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": \"MAD\",\n  \"pick_confidence_threshold\": 0.2,\n  \"min_stations\": 3,\n  \"ignore_boundary\": false,\n  \"ignore_boundary_width\": \"root_node_size\",\n  \"node_interpolation\": true,\n  \"detection_blinding\": \"PT1S\",\n  \"power_mean\": 1.0,\n  \"window_length\": \"PT5M\",\n  \"n_threads_parstack\": \"auto\",\n  \"n_threads_argmax\": \"auto\",\n  \"save_images\": false,\n  \"created\": \"2025-10-01T16:09:49.154945Z\"\n}\n</code></pre>"},{"location":"components/configuration/#minimal-config","title":"Minimal Config","text":"<p>This is a minimal config which can used to start a Qseek search.</p> Minimal Qseek Config<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"station_xmls\": [],\n    \"pyrocko_station_yamls\": [\"search/pyrocko-stations.yaml\"],\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": \".\",\n    \"waveform_dirs\": [\"data/\"],\n  },\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 2000.0,\n    \"n_levels\": 3,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ],\n    \"absorbing_boundary\": 1000.0\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"PhaseNet\",\n      \"model\": \"ethz\",\n      \"torch_use_cuda\": false,\n      \"phase_map\": {\n        \"P\": \"constant:P\",\n        \"S\": \"constant:S\"\n      },\n    }\n  ],\n  \"ray_tracers\": [\n    {\n    \"tracer\": \"ConstantVelocityTracer\",\n    \"phase\": \"constant:P\",\n    \"velocity\": 5000.0\n    }\n  ],\n  \"station_corrections\": {},\n  \"event_features\": [],\n  \"sampling_rate\": 100,\n  \"detection_threshold\": 0.05,\n  \"detection_blinding\": \"PT2S\",\n  \"node_split_threshold\": 0.9,\n  \"window_length\": \"PT300S\",\n  \"n_threads_parstack\": 0,\n  \"n_threads_argmax\": 4,\n}\n</code></pre>"},{"location":"components/configuration/#structure","title":"Structure","text":"<p>Structure of the search and optimisation of the octree, which is focusing in on seismic energy.</p> <pre><code>%%{init: {'theme': 'neutral', 'themeVariables': { 'fontSize': '14pt'}}}%%\nflowchart LR\n    subgraph Seismic Data\n        waveforms([\"fa:fa-water Seismic\\nWaveforms\"])\n        image{{\"fa:fa-bolt Waveform Image Function\\nPhaseNet / EQTransformer / ...\"}}\n        waveforms --&gt; image\n    end\n    subgraph Travel Time Model\n        travelTimes([\"fa:fa-layer-group Seismic\\nTravel Time Model\"])\n        stationCorrections{{\"fab:fa-arrows-to-dot Station Corrections\\nSST / SSST\"}}\n        travelTimes --&gt;|add| stationCorrections\n    end\n    subgraph Stacking and Migration\n        octree[\"fa:fa-cubes\\nOctree Grid\"]\n        detection[\"fa:fa-bullseye Detection\\nand Localisation\"]\n    end\n    featureExtraction(\"fa:fa-info Extract Event Features\\nMagnitudes, Ground Motion, ...\")\n    correctionExtraction(\"fa:fa-stopwatch Extract\\nStation Corrections\")\n\n    image --&gt; octree\n    stationCorrections --&gt; octree\n    detection -.-&gt;|\"fa:fa-cube\\nRefine\"| octree\n    octree --&gt; detection\n    detection --&gt; featureExtraction &amp; correctionExtraction\n</code></pre> <p>Building blocks of the specific stacking and migration method for earthquake detection, localisation and characterisation.</p>"},{"location":"components/general/","title":"General Settings","text":""},{"location":"components/general/#paths","title":"Paths","text":"<p>Paths can be relative to the location of the config file or absolute. File paths and directory paths are checked whether they exist.</p>"},{"location":"components/general/#date-and-time","title":"Date and Time","text":"<p>Serialisation of time, dates and date times and durations follow ISO8601 format with timezone information. E.g. <code>2023-10-28T01:21:21.003Z</code>.</p> <p>Duration are serialized like <code>PT600S</code>, this example shows a duration of 600 seconds, 10 minutes.</p> <p>!!!+ note Timezone Info     All datetimes are timezone aware! For UTC this is the <code>Z</code> or <code>+00:00</code> suffix.     Also other offsets can be defined according to ISO8601.</p> Example of datetimes and durations<pre><code>{\n    \"start_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"end_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"duration\": \"PT600S\"\n}\n</code></pre>"},{"location":"components/general/#locations","title":"Locations","text":"<p>Geographic locations have a geographic reference and a relative shift in meters. The octree or velocity models are referenced using Location objects.</p> <p>All distances, depths and elevations are given in meters.</p> <p></p>"},{"location":"components/general/#exec-4--location-module","title":"Location Module","text":"Config LocationJSON  <code>lat</code>: <code>PydanticUndefined</code> <p>Latitude in degrees.</p> <code>lon</code>: <code>PydanticUndefined</code> <p>Longitude in degrees.</p> <code>east_shift</code>: <code>0.0</code> <p>East shift towards geographical reference in meters.</p> <code>north_shift</code>: <code>0.0</code> <p>North shift towards geographical reference in meters.</p> <code>elevation</code>: <code>0.0</code> <p>Elevation in meters.</p> <code>depth</code>: <code>0.0</code> <p>Depth in meters, positive is down.</p> JSON for Location<pre><code>{\n  \"lat\": 52.3825,\n  \"lon\": 13.0644,\n  \"east_shift\": 0.0,\n  \"north_shift\": 0.0,\n  \"elevation\": 0.0,\n  \"depth\": 0.0\n}\n</code></pre>"},{"location":"components/image_function/","title":"Phase Arrival Image Function","text":"<p>For image functions this version of Qseek relies heavily on machine learning phase-arrival pickers delivered by SeisBench.</p>"},{"location":"components/image_function/#seisbench-image-function","title":"SeisBench Image Function","text":"<p>SeisBench offers access to a variety of machine learning phase pickers pre-trained on various data sets.</p> <p>Citation PhaseNet</p> <p>Zhu, Weiqiang, and Gregory C. Beroza. \"PhaseNet: A Deep-Neural-Network-Based Seismic Arrival Time Picking Method.\" arXiv preprint arXiv:1803.03211 (2018).</p> <p></p>"},{"location":"components/image_function/#exec-5--seisbench-module","title":"SeisBench Module","text":"<p>PhaseNet image function. For more details see SeisBench documentation.</p> Config SeisBenchJSON  <code>model</code>: <code>PhaseNet | EQTransformer | OBSTransformer | LFEDetect | GPD</code> <p>The model to use for the image function. Currently supported models are <code>PhaseNet</code>, <code>EQTransformer</code>, <code>GPD</code>, <code>OBSTransformer</code>, <code>LFEDetect</code>.</p> <code>pretrained</code>: <code>cascadia | cms | diting | dummy | ethz | geofon | instance | iquique | jcms | jcs | jms | lendb | mexico | nankai | neic | obs | obst2024 | original | original_nonconservative | san_andreas | scedc | stead | volpick</code> <p>SeisBench pre-trained model to use. Choose from <code>ethz</code>, <code>geofon</code>, <code>instance</code>, <code>iquique</code>, <code>lendb</code>, <code>neic</code>, <code>obs</code>, <code>original</code>, <code>scedc</code>, <code>stead</code>. For more details see SeisBench documentation</p> <code>window_overlap_samples</code>: <code>1500</code> <p>Window overlap in samples.</p> <code>torch_use_cuda</code> <p>Use CUDA for inference. If <code>True</code> use default device, if <code>int</code> use the specified device.</p> <code>torch_cpu_threads</code>: <code>4</code> <p>Number of CPU threads to use if only CPU is used.</p> <code>batch_size</code>: <code>128</code> <p>Batch size for inference, larger values can improve performance.</p> <code>stack_method</code>: <code>avg | max</code> <p>Method to stack the overlaping blocks internally. Choose from <code>avg</code> and <code>max</code>.</p> <code>sampling_rate</code>: <code>100.0</code> <p>Upscale input by factor. This augments the input data from e.g. 100 Hz to 50 Hz (factor: <code>2</code>). Can be useful for high-frequency microseismic events.</p> <code>phase_map</code> <p>Phase mapping from SeisBench PhaseNet to Lassie phases.</p> <code>weights</code> <p>Weights for each phase.</p> JSON for SeisBench<pre><code>{\n  \"image\": \"SeisBench\",\n  \"model\": \"PhaseNet\",\n  \"pretrained\": \"original\",\n  \"window_overlap_samples\": 1500,\n  \"torch_use_cuda\": true,\n  \"torch_cpu_threads\": 4,\n  \"batch_size\": 128,\n  \"stack_method\": \"avg\",\n  \"sampling_rate\": 100.0,\n  \"phase_map\": {\n    \"P\": \"cake:P\",\n    \"S\": \"cake:S\"\n  },\n  \"weights\": {\n    \"P\": 1.0,\n    \"S\": 1.0\n  }\n}\n</code></pre>"},{"location":"components/magnitudes/","title":"Earthquake Magnitude Calculation","text":"<p>Qseek supports earthquake magnitude calculation as Local Magnitudes in different attenuation models and Moment Magnitudes derived from forward-modelled attenuation curves.</p>"},{"location":"components/magnitudes/#local-magnitude","title":"Local Magnitude","text":"<p>Local magnitude calculation relies on a tuned attenuation model.</p> <p></p>"},{"location":"components/magnitudes/#exec-6--localmagnitudeextractor-module","title":"LocalMagnitudeExtractor Module","text":"<p>Local magnitude calculator for different regional models.</p> Config LocalMagnitudeExtractorJSON  <code>noise_window</code>: <code>5.0</code> <p>Waveforms to extract before P phase arrival. The noise amplitude is extracted from before the P phase arrival, with 0.5 s padding.</p> <code>seconds_after</code>: <code>4.0</code> <p>Waveforms to extract after S phase arrival.</p> <code>taper_seconds</code>: <code>10.0</code> <p>Seconds tapering before and after the extraction window. The taper stabalizes the restitution and is cut off from the traces before the analysis.</p> <code>min_signal_noise_ratio</code>: <code>1.5</code> <p>Minimum signal-to-noise ratio for the local magnitude estimation. The noise amplitude is extracted from before the P phase arrival, with 0.5 s padding.</p> <code>max_station_std</code>: <code>3.0</code> <p>Maximum standard deviation of the station magnitudes to include in the local magnitude estimation.</p> <code>model</code>: <code>webnet-western-bohemia | southern-california | central-california | iaspei-southern-california | eastern-north-america | albania | south-west-germany | south-australia | norway-fennoscandia | iceland-askja | iceland-bardabunga | iceland-askja-bardabunga-combined | iceland-reykjanes | azores | argentina-volcanoes | netherlands-groningen</code> <p>The amplitude attenuation model to use for calculating the local magnitude.</p> <code>export_mseed</code> <p>Path to export the processed mseed traces to.</p> JSON for LocalMagnitudeExtractor<pre><code>{\n  \"magnitude\": \"LocalMagnitude\",\n  \"noise_window\": 5.0,\n  \"seconds_after\": 4.0,\n  \"taper_seconds\": 10.0,\n  \"min_signal_noise_ratio\": 1.5,\n  \"max_station_std\": 3.0,\n  \"model\": \"iaspei-southern-california\",\n  \"export_mseed\": null\n}\n</code></pre>"},{"location":"components/magnitudes/#moment-magnitude","title":"Moment Magnitude","text":"<p>Based on forward-modelled attenuation curves using Pyrocko-GF. For more information on the method see Dahm et al., 2024.</p> <p></p>"},{"location":"components/magnitudes/#exec-7--momentmagnitudeextractor-module","title":"MomentMagnitudeExtractor Module","text":"<p>Moment magnitude calculator from peak amplitudes.</p> Config MomentMagnitudeExtractorJSON  <code>noise_window</code>: <code>5.0</code> <p>Waveforms to extract before P phase arrival. The noise amplitude is extracted from before the P phase arrival, with a one second padding.</p> <code>seconds_after</code>: <code>4.0</code> <p>Waveforms to extract after S phase arrival.</p> <code>taper_seconds</code>: <code>10.0</code> <p>Seconds tapering before and after the extraction window. The taper stabalizes the restitution and is cut off from the traces before the analysis.</p> <code>min_signal_noise_ratio</code>: <code>1.5</code> <p>Minimum signal-to-noise ratio for the magnitude estimation. The noise amplitude is extracted from before the P phase arrival, with 0.5 s padding.</p> <code>max_station_std</code>: <code>3.0</code> <p>Maximum standard deviation of the station magnitudes to include in the local magnitude estimation.</p> <code>gf_store_dirs</code> <p>The directories of the Pyrocko GF stores.</p> <code>export_mseed</code> <p>Path to export the processed mseed traces to.</p> <code>models</code> <p>The peak amplitude models to use.</p> JSON for MomentMagnitudeExtractor<pre><code>{\n  \"magnitude\": \"MomentMagnitude\",\n  \"noise_window\": 5.0,\n  \"seconds_after\": 4.0,\n  \"taper_seconds\": 10.0,\n  \"min_signal_noise_ratio\": 1.5,\n  \"max_station_std\": 3.0,\n  \"gf_store_dirs\": [\n    \".\"\n  ],\n  \"export_mseed\": null,\n  \"models\": [\n    {\n      \"gf_store_id\": \"moment_magnitude\",\n      \"quantity\": \"displacement\",\n      \"frequency_range\": [\n        2.0,\n        20.0\n      ],\n      \"max_distance\": 100000.0,\n      \"source_depth_delta\": 1000.0,\n      \"reference_magnitude\": 1.0,\n      \"rupture_velocities\": [\n        0.8,\n        0.9\n      ],\n      \"stress_drop\": [\n        1000000.0,\n        10000000.0\n      ],\n      \"gf_interpolation\": \"multilinear\",\n      \"nsl_id\": null,\n      \"peak_amplitude\": \"absolute\",\n      \"station_epicentral_range\": [\n        1000.0,\n        100000.0\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"components/octree/","title":"Octree Search Volume","text":"<p>A 3D space is searched for sources of seismic energy. Qseek created an octree structure which is iteratively refined when energy is detected, to focus on the source' location. This speeds up the search and improves the resolution of the localisations.</p> <p></p> <p>Surface projection of the refined octree focusing on the seismic source region. In this example four levels of refinement are can be seen, refining the 3D octree from the initial 4000 nodes to 8823 nodes.</p> <p></p>"},{"location":"components/octree/#exec-8--octree-module","title":"Octree Module","text":"Config OctreeJSON  <code>location</code> <p>The geographical center of the octree.</p> <code>root_node_size</code>: <code>1000.0</code> <p>Size of the root node at the initial level (level 0) in meters.</p> <code>n_levels</code>: <code>5</code> <p>Number of levels in the octree, defining the final resolution of the detection. Default is 5.</p> <code>east_bounds</code> <p>East bounds of the octree in meters.</p> <code>north_bounds</code> <p>North bounds of the octree in meters.</p> <code>depth_bounds</code> <p>Depth bounds of the octree in meters.</p> JSON for Octree<pre><code>{\n  \"location\": {\n    \"lat\": 0.0,\n    \"lon\": 0.0,\n    \"east_shift\": 0.0,\n    \"north_shift\": 0.0,\n    \"elevation\": 0.0,\n    \"depth\": 0.0\n  },\n  \"root_node_size\": 1000.0,\n  \"n_levels\": 5,\n  \"east_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"north_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"depth_bounds\": [\n    0.0,\n    20000.0\n  ]\n}\n</code></pre>"},{"location":"components/ray_tracer/","title":"Ray Tracers","text":"<p>The calculation of seismic travel times is a cornerstone for the migration and stacking approach. Qseek supports different ray tracers for travel time calculation, which can be adapted for different geological settings.</p>"},{"location":"components/ray_tracer/#constant-velocity","title":"Constant Velocity","text":"<p>The constant velocity models is trivial and follows:</p> \\[ t_{P} = \\frac{d}{v_P} \\] <p>This module is used for simple use cases and cross-referencing testing.</p> <p></p>"},{"location":"components/ray_tracer/#exec-9--constantvelocitytracer-module","title":"ConstantVelocityTracer Module","text":"<p>Travel time tracer with a constant velocity.</p> Config ConstantVelocityTracerJSON  <code>phase</code>: <code>constant:P</code> <p>Name of the phase.</p> <code>velocity</code>: <code>5000.0</code> <p>Constant velocity of the phase in m/s.</p> JSON for ConstantVelocityTracer<pre><code>{\n  \"tracer\": \"ConstantVelocityTracer\",\n  \"phase\": \"constant:P\",\n  \"velocity\": 5000.0\n}\n</code></pre>"},{"location":"components/ray_tracer/#1d-layered-velocity-model","title":"1D Layered Velocity Model","text":"<p>Travel times for 1D layered velocity models can be calculated by two different modules.</p> <p></p> <p>Calculation of travel times in 1D layered media is based on the Pyrocko Cake ray tracer.</p> <p></p> <p>Pyrocko Cake 1D ray tracer for travel time calculation in 1D layered media</p> <p></p>"},{"location":"components/ray_tracer/#exec-10--fastmarchingtracer-module","title":"FastMarchingTracer Module","text":"<p>Travel time calculation for layered 1D velocity models.</p> <p>Calculation is based on fast marching method to solve the Eikonal solution. This the more perfomant than the Pyrocko Cake ray tracer, especially for large number of stations and nodes.</p> Config FastMarchingTracerJSON  <code>velocity_model</code> <p>Velocity model for the ray tracer.</p> <code>interpolation_method</code>: <code>nearest | linear | cubic</code> <p>Interpolation method for travel times in the volume. Choose from <code>nearest</code>, <code>linear</code> or <code>cubic</code>.</p> <code>nthreads</code>: <code>0</code> <p>Number of threads to use for travel time. If set to <code>0</code>, <code>cpu_count*2</code> will be used.</p> <code>implementation</code>: <code>pyrocko | scikit-fmm</code> <p>Implementation of the Fast Marching Method. Pyrocko only supports first-order FMM for now.</p> <code>phases</code> <p>Phases to calculate.</p> JSON for FastMarchingTracer<pre><code>{\n  \"tracer\": \"FastMarching\",\n  \"velocity_model\": {\n    \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n    \"format\": \"nd\",\n    \"crust2_profile\": \"\",\n    \"raw_file_data\": null\n  },\n  \"interpolation_method\": \"linear\",\n  \"nthreads\": 0,\n  \"implementation\": \"scikit-fmm\",\n  \"phases\": [\n    \"fm:P\",\n    \"fm:S\"\n  ]\n}\n</code></pre>"},{"location":"components/ray_tracer/#exec-11--caketracer-module","title":"CakeTracer Module","text":"<p>Travel time calculation for 1D layered velocity models.</p> <p>Calculation is based on Pyrocko Cake ray tracer.</p> Config CakeTracerJSON  <code>phases</code> <p>Dictionary of phases and timings to calculate.</p> <code>earthmodel</code> <p>Earth model to calculate travel times for.</p> JSON for CakeTracer<pre><code>{\n  \"tracer\": \"CakeTracer\",\n  \"phases\": {\n    \"cake:P\": {\n      \"definition\": \"P,p\"\n    },\n    \"cake:S\": {\n      \"definition\": \"S,s\"\n    }\n  },\n  \"earthmodel\": {\n    \"filename\": \"/home/runner/.cache/qseek/velocity_models/default.nd\",\n    \"format\": \"nd\",\n    \"crust2_profile\": \"\"\n  }\n}\n</code></pre>"},{"location":"components/ray_tracer/#3d-velocity-model","title":"3D Velocity Model \ud83d\ude80","text":"<p>We implement the fast marching method for calculating first arrivals of waves in 3D volumes. Currently three different 3D velocity models are supported:</p> <ul> <li> Import NonLinLoc 3D velocity model</li> <li> 1D layered model \ud83e\udd5e</li> <li> Constant velocity, mainly for testing purposes \ud83e\udd7c</li> </ul> <p></p> <p>Conceptual 2D visualisation for seismic traveltimes calculation in heterogenous media using the fast-marching method for the Eikonal solution is presented. Traveltimes from the receiving station at the surface (indicated by a yellow triangle) towards the subsurface grid are calculated, resulting in station-specifig traveltimes for all potential source locations simultaneously.</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/markdown_exec/_internal/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/markdown_exec/_internal/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n10&gt;\", line 2, in &lt;module&gt;\n    from qseek.insights.tracers.fast_marching_3d import FastMarching3DTracer\nModuleNotFoundError: No module named 'qseek.insights'\n</code></pre>"},{"location":"components/ray_tracer/#visualizing-3d-models","title":"Visualizing 3D Models","text":"<p>For quality check, all 3D velocity models are exported to <code>vtk/</code> folder as <code>.vti</code> files. Use ParaView to inspect and explore the velocity models.</p> <p> Seismic velocity model of the Utah FORGE testbed site, visualized in ParaView.</p>"},{"location":"components/station_corrections/","title":"Station Corrections","text":"<p>Station corrections can be extract from previous runs to refine the localisation accuracy. The corrections can also help to improve the semblance find more events in a dataset.</p>"},{"location":"components/station_corrections/#station-specific-corrections","title":"Station Specific Corrections","text":"<p>Statistics of station delay times.</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/markdown_exec/_internal/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/markdown_exec/_internal/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n11&gt;\", line 2, in &lt;module&gt;\n    from qseek.insights import StationCorrections\nModuleNotFoundError: No module named 'qseek.insights'\n</code></pre>"},{"location":"components/station_corrections/#source-specific-corrections","title":"Source Specific Corrections","text":"<p>Delay volume for a selected stations.</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/markdown_exec/_internal/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/markdown_exec/_internal/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n12&gt;\", line 2, in &lt;module&gt;\n    from qseek.insights import SourceSpecificStationCorrections\nModuleNotFoundError: No module named 'qseek.insights'\n</code></pre>"},{"location":"components/station_metadata/","title":"Station Metadata","text":"<p>Station metadata is required primarily for station locations and codes.</p> <p>Supported data formats are:</p> <ul> <li> StationXML</li> <li> Pyrocko Station YAML</li> </ul> <p>If local magnitudes M<sub>L</sub> are extracted, response information as StationXML is required.</p> <p></p>"},{"location":"components/station_metadata/#exec-15--stations-module","title":"Stations Module","text":"Config StationsJSON  <code>pyrocko_station_yamls</code> <p>List of Pyrocko station YAML files.</p> <code>station_xmls</code> <p>List of StationXML files or directories containing StationXML (.xml) files.</p> <code>blacklist</code> <p>Blacklist stations and exclude from detecion. Format is <code>['NET.STA.LOC', ...]</code>.</p> <code>max_distance</code> <p>Maximum distance in meters from the centroid location to include stations for detection. If None, all stations are included.</p> JSON for Stations<pre><code>{\n  \"pyrocko_station_yamls\": [],\n  \"station_xmls\": [],\n  \"blacklist\": [],\n  \"stations\": [],\n  \"max_distance\": null\n}\n</code></pre>"},{"location":"components/waveform_data/","title":"Waveform Data","text":"<p>The seismic can be delivered in MiniSeed or any other format compatible with Pyrocko. Qseek utilizes the Pyrocko Squirrel for fast and asynchronous data access.</p> <p>To prepare your data for EQ detection and localisation, organize it in a MiniSeed file or an SDS structure.</p>"},{"location":"components/waveform_data/#local-waveform-data","title":"Local Waveform Data","text":"<p>To copy large data from FDSN data centers use fdsn-fetch.</p> <p></p>"},{"location":"components/waveform_data/#exec-16--pyrockosquirrel-module","title":"PyrockoSquirrel Module","text":"<p>Waveform provider using Pyrocko's Squirrel.</p> Config PyrockoSquirrelJSON  <code>channel_selector</code> <p>Channel selector for waveforms, e.g. <code>['HH', 'EN']</code>.</p> <code>environment</code> <p>Path to a Pyrocko Squirrel environment.</p> <code>persistent</code> <p>Name of the Squirrel's persistent collection for faster loading of large data sets.</p> <code>waveform_dirs</code> <p>List of directories holding the waveform files.</p> <code>start_time</code> <p>Start time for the search in ISO8601 including timezone. E.g. <code>2024-12-30T00:00:00Z</code>.</p> <code>end_time</code> <p>End time for the search in ISO8601 including timezone. E.g. <code>2024-12-31T00:00:00Z</code>.</p> <code>n_threads</code>: <code>8</code> <p>Number of threads for loading waveforms, important for large data sets.</p> <code>watch_waveforms</code> <p>Watch the waveform directories for changes. If <code>True</code> it will check every ten minutes. If a <code>timedelta</code> is provided it will check every specified time. Default is False.</p> <code>queue_size</code>: <code>16</code> <p>Size of the internal queue for prefetching waveform batches.</p> JSON for PyrockoSquirrel<pre><code>{\n  \"provider\": \"PyrockoSquirrel\",\n  \"channel_selector\": null,\n  \"environment\": null,\n  \"persistent\": \"docs\",\n  \"waveform_dirs\": [\n    \"data\"\n  ],\n  \"start_time\": null,\n  \"end_time\": null,\n  \"n_threads\": 8,\n  \"watch_waveforms\": false,\n  \"queue_size\": 16\n}\n</code></pre>"},{"location":"components/waveform_data/#real-time-waveform-streaming","title":"Real-Time Waveform Streaming","text":""},{"location":"components/waveform_data/#exec-17--seedlink-module","title":"SeedLink Module","text":"<p>Waveform provider to connect to SeedLink real-time streams.</p> Config SeedLinkJSON  <code>channel_selector</code> <p>Channel selector for waveforms, e.g. <code>['HH', 'EN']</code>.</p> <code>timeout</code> <p>Maximum wait time for new traces.</p> <code>clients</code> <p>List of SeedLink clients to connect to. If multiple clients are given, they will be used in parallel.</p> <code>save_sds_archive</code> <p>Path to save MiniSeed in an SDS structure. Give a path to save the archive, or True to use the default path. If False, no saving is done.</p> JSON for SeedLink<pre><code>{\n  \"provider\": \"SeedLink\",\n  \"channel_selector\": null,\n  \"timeout\": \"PT20S\",\n  \"clients\": [\n    {\n      \"host\": \"geofon.gfz-potsdam.de\",\n      \"port\": 18000,\n      \"station_selection\": [\n        {\n          \"nsl\": \"1D.SYRAU.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"1D.WBERG.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.KOC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.KRC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.LBC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.SKC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.STC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.VAC.\",\n          \"channel\": \"HH?\"\n        }\n      ],\n      \"buffer_length\": \"PT30M\",\n      \"reconnect_timeout\": 60.0\n    }\n  ],\n  \"save_sds_archive\": \"sds-seedlink\"\n}\n</code></pre>"}]}