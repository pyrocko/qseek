{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Qseek \ud83d\udd25","text":"<p>Qseek is an earthquake detection and localisation framework. It combines modern machine learning phase detection and robust migration and stacking techniques.</p> <p>The detector is leveraging Pyrocko and SeisBench, it is highly-performant and can search massive data sets for seismic activity efficiently.</p> <p>Citation</p> <p>Isken, M., Niemz, P., M\u00fcnchmeyer, J., B\u00fcy\u00fckakp\u0131nar, P., Heimann, S., Cesca, S., Vasyura-Bathke, H., &amp; Dahm, T. (2025). Qseek: A data-driven Framework for Automated Earthquake Detection, Localization and Characterization. Seismica, 4(1). https://doi.org/10.26443/seismica.v4i1.1283</p> <p></p> <p>Seismic swarm activity in Iceland, Reykjanes Peninsula during a 2020 unrest. 30k+ earthquakes detected, outlining a dike intrusion, preceeding the 2021 Fagradasfjall eruption.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Earthquake phase detection using machine-learning pickers from SeisBench</li> <li> PhaseNet (Zhu and Beroza, 2018</li> <li> EQTransformer (Mousavi et al., 2020)</li> <li> OBSTransformer (Niksejel and Zahng, 2024)</li> <li> LFEDetect</li> <li> Octree localisation approach for efficient and accurate search</li> <li> Different velocity models:</li> <li> Constant velocity</li> <li> 1D Layered velocity model</li> <li> 3D fast-marching velocity model (NonLinLoc compatible)</li> <li> Extraction of earthquake event features:</li> <li> Local magnitudes</li> <li> Ground motion attributes</li> <li> Automatic extraction of modelled and picked travel times</li> <li> Calculation and application of station corrections / station delay times</li> <li> Real-time analytics on streaming data (e.g. SeedLink)</li> </ul> <p>Get Started!</p>"},{"location":"#supported-by","title":"Supported by","text":""},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#computation-performance","title":"Computation Performance","text":"<p>Qseek is built for searching in large-N data sets. The implementation is leveraging Python <code>asyncio</code> heavily to implement threading and keeping the CPU busy. It is built on top of highly performant Pyrocko functions implemented in C language. The inference is using PyTorch which enables GPU computation of the seismic imaging functions.</p> <p>This enables high throughput of seismic data in different scenarios.</p> Number Stations Throughput in MB Throughput in Waveform data 300+ 50 MB/sec 12 hours/sec 50 200 MB/sec 6 hours/sec <p>Scanning a 600 GB (~700 years of waveforms) data set costs ~2 days on a 64 cores machine equipped with an Nvidia A100 GPU.</p> <p>Note</p> <p>The performance depends heavily on the octree resolution and the number of events detected in the data set.</p>"},{"location":"benchmark/#related-projects","title":"Related Projects","text":"<p>A list of other projects using stacking and migration approach to back-project seismic energy sources in 3D space:</p>"},{"location":"benchmark/#lassie-v1","title":"Lassie-v1","text":"<p>Lassie - The friendly Earthquake detector in version 1. Qseek utilizes the same optimized heavy-duty functions for stacking and migration as Lassie v1.</p> <p>Lassie-v1 on Pyrocko Git</p>"},{"location":"benchmark/#quakemigrate","title":"QuakeMigrate","text":"<p>QuakeMigrate uses a waveform migration and stacking algorithm to search for coherent seismic phase arrivals across a network of instruments. It produces\u2014from raw data\u2014catalogues of earthquakes with locations, origin times, phase arrival picks, and local magnitude estimates, as well as rigorous estimates of the associated uncertainties.</p> <p>QuakeMigrate on GitHub</p>"},{"location":"benchmark/#bpmf","title":"BPMF","text":"<p>Complete framework for earthquake detection and location: Backprojection and matched-filtering (BPMF), with methods for automatic picking, relocation and efficient waveform stacking.</p> <p>BPMF on GitHub</p>"},{"location":"benchmark/#loki","title":"Loki","text":"<p>LOKI (LOcation of seismic events through traveltime staKIng) is a code that performs earthquake detection and location using waveform coherence analysis (waveform stacking).</p> <p>Loki on GitHub</p>"},{"location":"benchmark/#malmi","title":"MALMI","text":"<p>MALMI (MAchine Learning aided earthquake MIgration location), variant of Loki for detecting and locating earthquakes using ML image functions provided by SeisBench.</p> <p>MALMI on GitHub</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>The installation is straight-forward using pip or pipx.</p> From GitHub<pre><code>pip install git+https://github.com/pyrocko/qseek\n</code></pre> From GitHub the Development Branch<pre><code>pip install git+https://github.com/pyrocko/qseek@dev\n</code></pre> <p>or</p> Using pipx<pre><code>pipx install git+https://github.com/pyrocko/qseek\n</code></pre>"},{"location":"getting_started/#running-qseek","title":"Running Qseek","text":"<p>The main entry point in the executeable is the <code>qseek</code> command. The provided command line interface (CLI) and a JSON config file is all what is needed to run the program.</p> <pre><code>qseek --help\n</code></pre> <pre><code>usage: qseek [-h] [--verbose] [--version]\n             {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas} ...\n\nqseek - The wholesome earthquake detector \ud83d\ude80\n\noptions:\n  -h, --help            show this help message and exit\n  --verbose, -v         increase verbosity of the log messages, repeat to\n                        increase. Default level is INFO\n  --version             show version and exit\n\ncommands:\n  Available commands to run qseek. Get command help with `qseek &lt;command&gt;\n  --help`.\n\n  {config,search,continue,snuffler,feature-extraction,modules,serve,export,clear-cache,dump-schemas}\n    config              print a new config\n    search              start a search\n    continue            continue an existing search\n    snuffler            start the Pyrocko snuffler to inspect waveforms,\n                        events and picks\n    feature-extraction  extract features from an existing run\n    modules             show available modules\n    serve               start webserver and serve results from an existing run\n    export              export detections to different output formats\n    clear-cache         clear the cach directory\n    dump-schemas        dump data models to json-schema (development)\n</code></pre>"},{"location":"getting_started/#initializing-a-new-project","title":"Initializing a New Project","text":"<p>Once installed you can run the <code>qseek</code> executeable to initialize a new project.</p> Initialize new Project<pre><code>qseek config &gt; my-search.json\n</code></pre> <p>Check out the <code>my-search.json</code> config file and add your waveform data and velocity models.</p> Minimal Configuration Example <p>Here is a minimal JSON configuration for Qseek. <pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": [],\n    \"max_distance\": null\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"channel_selector\": null,\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [\n      \"data\"\n    ],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"n_threads\": 8,\n    \"watch_waveforms\": false,\n    \"queue_size\": 16\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true,\n      \"zero_phase\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"sampling_rate\": 100.0,\n      \"phase_map\": {\n        \"P\": \"cake:P\",\n        \"S\": \"cake:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"FastMarching3D\",\n      \"phase\": \"fmm3d:P\",\n      \"interpolation_method\": \"cubic\",\n      \"nthreads\": 0,\n      \"velocity_model\": {\n        \"model\": \"Constant3DVelocityModel\",\n        \"grid_spacing\": \"octree\",\n        \"velocity\": 5000.0\n      },\n      \"implementation\": \"scikit-fmm\"\n    },\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      }\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    },\n    {\n      \"tracer\": \"FastMarching\",\n      \"velocity_model\": {\n        \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      },\n      \"interpolation_method\": \"linear\",\n      \"nthreads\": 0,\n      \"implementation\": \"pyrocko\",\n      \"phases\": [\n        \"fm:P\",\n        \"fm:S\"\n      ]\n    }\n  ],\n  \"distance_weights\": {\n    \"distance_taper\": \"mean_interstation\",\n    \"required_closest_stations\": 4,\n    \"waterlevel\": 0.0\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": \"MAD\",\n  \"pick_confidence_threshold\": 0.2,\n  \"min_stations\": 3,\n  \"ignore_boundary\": false,\n  \"ignore_boundary_width\": \"root_node_size\",\n  \"node_interpolation\": true,\n  \"detection_blinding\": \"PT1S\",\n  \"window_length\": \"PT5M\",\n  \"n_threads\": \"auto\",\n  \"save_images\": false,\n  \"created\": \"2026-01-10T19:05:37.242773Z\"\n}\n</code></pre></p> <p>For more details and information about the component, head over to details of the modules.</p>"},{"location":"getting_started/#starting-the-search","title":"Starting the Search","text":"<p>Once happy with the configuration, start the <code>qseek</code> CLI.</p> Start the earthquake detection and localization<pre><code>qseek search my-search.json\n</code></pre>"},{"location":"visualizing_results/","title":"Visualizing Detections","text":"<p>The event detections are exported in Qseek-native JSON, Pyrocko YAML format and as CSV files.</p>"},{"location":"visualizing_results/#pyrocko-sparrow","title":"Pyrocko Sparrow","text":"<p>For large data sets use the Pyrocko Sparrow to visualise seismic event detections in 3D. Also seismic stations and many other features from the Pyrocko ecosystem can be integrated into the view.</p> <p></p>"},{"location":"visualizing_results/#qgis","title":"QGIS","text":"<p>QGIS can be used to import <code>.csv</code> and explore the data in an interactive fashion. Detections can be rendered by e.g. the detection semblance or the calculated magnitude.</p> <p></p>"},{"location":"api/models/","title":"Models","text":""},{"location":"api/models/#qseek.models.location.Location","title":"qseek.models.location.Location  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>lat</code>                 (<code>float</code>)             </li> <li> <code>lon</code>                 (<code>float</code>)             </li> <li> <code>east_shift</code>                 (<code>float</code>)             </li> <li> <code>north_shift</code>                 (<code>float</code>)             </li> <li> <code>elevation</code>                 (<code>float</code>)             </li> <li> <code>depth</code>                 (<code>float</code>)             </li> <li> <code>_cached_lat_lon</code>                 (<code>tuple[float, float]</code>)             </li> <li> <code>_cached_origin</code>                 (<code>Location | None</code>)             </li> </ul>"},{"location":"api/models/#qseek.models.location.Location.depth","title":"depth  <code>pydantic-field</code>","text":"<pre><code>depth: float = 0.0\n</code></pre> <p>Depth in meters, positive is down.</p>"},{"location":"api/models/#qseek.models.location.Location.east_shift","title":"east_shift  <code>pydantic-field</code>","text":"<pre><code>east_shift: float = 0.0\n</code></pre> <p>East shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.location.Location.effective_lat_lon","title":"effective_lat_lon  <code>property</code>","text":"<pre><code>effective_lat_lon: tuple[float, float]\n</code></pre> <p>Shift-corrected lat/lon pair of the location.</p>"},{"location":"api/models/#qseek.models.location.Location.elevation","title":"elevation  <code>pydantic-field</code>","text":"<pre><code>elevation: float = 0.0\n</code></pre> <p>Elevation in meters.</p>"},{"location":"api/models/#qseek.models.location.Location.lat","title":"lat  <code>pydantic-field</code>","text":"<pre><code>lat: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/models/#qseek.models.location.Location.lon","title":"lon  <code>pydantic-field</code>","text":"<pre><code>lon: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/models/#qseek.models.location.Location.north_shift","title":"north_shift  <code>pydantic-field</code>","text":"<pre><code>north_shift: float = 0.0\n</code></pre> <p>North shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.location.Location.as_wkt","title":"as_wkt","text":"<pre><code>as_wkt() -&gt; str\n</code></pre> <p>Return the location as WKT string.</p>"},{"location":"api/models/#qseek.models.location.Location.azimuth_to","title":"azimuth_to","text":"<pre><code>azimuth_to(other: Location) -&gt; float\n</code></pre> <p>Compute azimuth [\u00b0] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The azimuth in [\u00b0].</p>"},{"location":"api/models/#qseek.models.location.Location.distance_to","title":"distance_to","text":"<pre><code>distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute 3-dimensional distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance in [m].</p>"},{"location":"api/models/#qseek.models.location.Location.offset_from","title":"offset_from","text":"<pre><code>offset_from(other: Location) -&gt; tuple[float, float, float]\n</code></pre> <p>Return offset vector (east, north, depth) from other location in [m].</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The offset vector.</p>"},{"location":"api/models/#qseek.models.location.Location.origin","title":"origin","text":"<pre><code>origin() -&gt; Location\n</code></pre> <p>Get the origin location.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>The origin location.</p>"},{"location":"api/models/#qseek.models.location.Location.shift","title":"shift","text":"<pre><code>shift(east: float, north: float, elevation: float) -&gt; Self\n</code></pre> <p>Shift the location by the given offsets.</p> <p>Parameters:</p> Name Type Description Default <code>east</code> <code>float</code> <p>East offset in [m].</p> required <code>north</code> <code>float</code> <p>North offset in [m].</p> required <code>elevation</code> <code>float</code> <p>Elevation offset in [m].</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.location.Location.shifted_origin","title":"shifted_origin","text":"<pre><code>shifted_origin() -&gt; Self\n</code></pre> <p>Shift the origin of the location to the effective lat/lon.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.location.Location.surface_distance_to","title":"surface_distance_to","text":"<pre><code>surface_distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute surface distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The surface distance in [m].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection","title":"qseek.models.detection.EventDetection  <code>pydantic-model</code>","text":"<p>               Bases: <code>Location</code></p> <p>Fields:</p> <ul> <li> <code>lat</code>                 (<code>float</code>)             </li> <li> <code>lon</code>                 (<code>float</code>)             </li> <li> <code>east_shift</code>                 (<code>float</code>)             </li> <li> <code>north_shift</code>                 (<code>float</code>)             </li> <li> <code>elevation</code>                 (<code>float</code>)             </li> <li> <code>depth</code>                 (<code>float</code>)             </li> <li> <code>_cached_lat_lon</code>                 (<code>tuple[float, float]</code>)             </li> <li> <code>_cached_origin</code>                 (<code>Location | None</code>)             </li> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>time</code>                 (<code>AwareDatetime</code>)             </li> <li> <code>semblance</code>                 (<code>PositiveFloat</code>)             </li> <li> <code>n_stations</code>                 (<code>int</code>)             </li> <li> <code>distance_border</code>                 (<code>PositiveFloat</code>)             </li> <li> <code>in_bounds</code>                 (<code>bool</code>)             </li> <li> <code>uncertainty</code>                 (<code>DetectionUncertainty | None</code>)             </li> <li> <code>magnitudes</code>                 (<code>list[EventMagnitudeType]</code>)             </li> <li> <code>features</code>                 (<code>list[EventFeaturesType]</code>)             </li> <li> <code>_receivers</code>                 (<code>EventReceivers | None</code>)             </li> <li> <code>_detection_idx</code>                 (<code>int | None</code>)             </li> <li> <code>_receiver_cache</code>                 (<code>ReceiverCache | None</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>migrate_features</code>                 \u2192                   <code>features</code> </li> </ul>"},{"location":"api/models/#qseek.models.detection.EventDetection.depth","title":"depth  <code>pydantic-field</code>","text":"<pre><code>depth: float = 0.0\n</code></pre> <p>Depth in meters, positive is down.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.distance_border","title":"distance_border  <code>pydantic-field</code>","text":"<pre><code>distance_border: PositiveFloat\n</code></pre> <p>Distance to the nearest border in meters. Only distance to NW, SW and bottom border is considered.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.east_shift","title":"east_shift  <code>pydantic-field</code>","text":"<pre><code>east_shift: float = 0.0\n</code></pre> <p>East shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.effective_lat_lon","title":"effective_lat_lon  <code>property</code>","text":"<pre><code>effective_lat_lon: tuple[float, float]\n</code></pre> <p>Shift-corrected lat/lon pair of the location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.elevation","title":"elevation  <code>pydantic-field</code>","text":"<pre><code>elevation: float = 0.0\n</code></pre> <p>Elevation in meters.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.features","title":"features  <code>pydantic-field</code>","text":"<pre><code>features: list[EventFeaturesType] = []\n</code></pre> <p>Event features.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.in_bounds","title":"in_bounds  <code>pydantic-field</code>","text":"<pre><code>in_bounds: bool = True\n</code></pre> <p>Is detection in bounds, and inside the configured border.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.lat","title":"lat  <code>pydantic-field</code>","text":"<pre><code>lat: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.lon","title":"lon  <code>pydantic-field</code>","text":"<pre><code>lon: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.magnitude","title":"magnitude  <code>property</code>","text":"<pre><code>magnitude: EventMagnitude | None\n</code></pre> <p>Returns the magnitude of the event.</p> <p>If there are no magnitudes available, returns None.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.magnitudes","title":"magnitudes  <code>pydantic-field</code>","text":"<pre><code>magnitudes: list[EventMagnitudeType] = []\n</code></pre> <p>Event magnitudes.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.n_picks","title":"n_picks  <code>property</code>","text":"<pre><code>n_picks: int\n</code></pre> <p>Number of phase picks in the detection.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.n_stations","title":"n_stations  <code>pydantic-field</code>","text":"<pre><code>n_stations: int = 0\n</code></pre> <p>Number of stations in the detection.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.north_shift","title":"north_shift  <code>pydantic-field</code>","text":"<pre><code>north_shift: float = 0.0\n</code></pre> <p>North shift towards geographical reference in meters.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.receivers","title":"receivers  <code>property</code>","text":"<pre><code>receivers: EventReceivers\n</code></pre> <p>Retrieves the event receivers associated with the detection.</p> <p>Returns:</p> Name Type Description <code>EventReceivers</code> <code>EventReceivers</code> <p>The event receivers associated with the detection.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the receivers cannot be fetched without a set rundir and detection index.</p> <code>ValueError</code> <p>If the receivers cannot be fetched due to missing rundir and index, or if there is a UID mismatch between the fetched receivers and the detection.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.semblance","title":"semblance  <code>pydantic-field</code>","text":"<pre><code>semblance: PositiveFloat\n</code></pre> <p>Detection semblance</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.time","title":"time  <code>pydantic-field</code>","text":"<pre><code>time: AwareDatetime\n</code></pre> <p>Detection time</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.uncertainty","title":"uncertainty  <code>pydantic-field</code>","text":"<pre><code>uncertainty: DetectionUncertainty | None = None\n</code></pre> <p>Detection uncertainty.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.add_feature","title":"add_feature","text":"<pre><code>add_feature(feature: EventFeature) -&gt; None\n</code></pre> <p>Add feature to the feature set.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>EventFeature</code> <p>Feature to add</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.add_magnitude","title":"add_magnitude","text":"<pre><code>add_magnitude(magnitude: EventMagnitude) -&gt; None\n</code></pre> <p>Add magnitude to detection.</p> <p>Parameters:</p> Name Type Description Default <code>magnitude</code> <code>EventMagnitudeType</code> <p>magnitude</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.as_pyrocko_event","title":"as_pyrocko_event","text":"<pre><code>as_pyrocko_event() -&gt; Event\n</code></pre> <p>Get detection as Pyrocko event.</p> <p>Returns:</p> Name Type Description <code>Event</code> <code>Event</code> <p>Pyrocko event</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.as_wkt","title":"as_wkt","text":"<pre><code>as_wkt() -&gt; str\n</code></pre> <p>Return the location as WKT string.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.azimuth_to","title":"azimuth_to","text":"<pre><code>azimuth_to(other: Location) -&gt; float\n</code></pre> <p>Compute azimuth [\u00b0] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The azimuth in [\u00b0].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.distance_to","title":"distance_to","text":"<pre><code>distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute 3-dimensional distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance in [m].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.export_csv_line","title":"export_csv_line","text":"<pre><code>export_csv_line(\n    file: Path, jitter_location: float = 0.0\n) -&gt; None\n</code></pre> <p>Save the detection as a CSV line.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>jitter_location</code> <code>float</code> <p>The amount of spatial jitter to apply. Defaults to 0.0.</p> <code>0.0</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.export_pyrocko_event","title":"export_pyrocko_event","text":"<pre><code>export_pyrocko_event(\n    file: Path, jitter_location: float = 0.0\n) -&gt; None\n</code></pre> <p>Write the detection as a Pyrocko event to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the output file.</p> required <code>jitter_location</code> <code>float</code> <p>The amount of spatial jitter to apply. Defaults to 0.0.</p> <code>0.0</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.export_pyrocko_markers","title":"export_pyrocko_markers","text":"<pre><code>export_pyrocko_markers(filename: Path) -&gt; None\n</code></pre> <p>Save detection's Pyrocko markers to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path to marker file</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.get_azimuthal_coverage","title":"get_azimuthal_coverage","text":"<pre><code>get_azimuthal_coverage(observed_only: bool = True) -&gt; float\n</code></pre> <p>Get azimuthal coverage of the detection.</p> <p>This is the reverse of the azimuthal gap: <code>360 - azimuthal_gap</code>.</p> <p>Parameters:</p> Name Type Description Default <code>observed_only</code> <code>bool</code> <p>Consider only observed azimuths. Defaults to True.</p> <code>True</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_azimuthal_gap","title":"get_azimuthal_gap","text":"<pre><code>get_azimuthal_gap(observed_only: bool = True) -&gt; float\n</code></pre> <p>Get maximum azimuthal gap of the detection.</p> <p>Parameters:</p> Name Type Description Default <code>observed_only</code> <code>bool</code> <p>Consider only observed azimuths. Defaults to True.</p> <code>True</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_csv_dict","title":"get_csv_dict","text":"<pre><code>get_csv_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get detection as CSV line.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: CSV line</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_pyrocko_markers","title":"get_pyrocko_markers","text":"<pre><code>get_pyrocko_markers(\n    modelled: bool = True, observed: bool = True\n) -&gt; list[EventMarker | PhaseMarker]\n</code></pre> <p>Get detections as Pyrocko markers.</p> <p>Parameters:</p> Name Type Description Default <code>modelled</code> <code>bool</code> <p>Include modelled arrivals. Defaults to True.</p> <code>True</code> <code>observed</code> <code>bool</code> <p>Include observed arrivals. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[EventMarker | PhaseMarker]</code> <p>list[marker.EventMarker | marker.PhaseMarker]: Pyrocko markers</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.get_receiver_azimuths","title":"get_receiver_azimuths","text":"<pre><code>get_receiver_azimuths(\n    observed_only: bool = True,\n) -&gt; dict[str, float]\n</code></pre> <p>Get receiver azimuths.</p> <p>Parameters:</p> Name Type Description Default <code>observed_only</code> <code>bool</code> <p>Return only observed azimuths. Defaults to False.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: Receiver azimuths</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.jitter_location","title":"jitter_location","text":"<pre><code>jitter_location(meters: float) -&gt; Self\n</code></pre> <p>Randomize detection location.</p> <p>Parameters:</p> Name Type Description Default <code>meters</code> <code>float</code> <p>maximum randomization in meters</p> required <p>Returns:</p> Name Type Description <code>EventDetection</code> <code>Self</code> <p>spatially jittered detection</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.offset_from","title":"offset_from","text":"<pre><code>offset_from(other: Location) -&gt; tuple[float, float, float]\n</code></pre> <p>Return offset vector (east, north, depth) from other location in [m].</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The offset vector.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.origin","title":"origin","text":"<pre><code>origin() -&gt; Location\n</code></pre> <p>Get the origin location.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>The origin location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.save","title":"save  <code>async</code>","text":"<pre><code>save(\n    rundir: Path,\n    update: bool = False,\n    jitter_location: float = 0.0,\n) -&gt; None\n</code></pre> <p>Dump the detection data to a file.</p> <p>After the detection is dumped, the receivers are dumped to a separate file and the receivers cache is cleared.</p> <p>Parameters:</p> Name Type Description Default <code>rundir</code> <code>Path</code> <p>The path to the rundir.</p> required <code>update</code> <code>bool</code> <p>Whether to update an existing detection or append a new one.</p> <code>False</code> <code>jitter_location</code> <code>float</code> <p>The amount of spatial jitter to apply to the exported detection. Defaults to 0.0.</p> <code>0.0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the detection index is not set and update is True.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.set_index","title":"set_index","text":"<pre><code>set_index(index: int, force: bool = False) -&gt; None\n</code></pre> <p>Set the index of the detection.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to set.</p> required <code>force</code> <code>bool</code> <p>Whether to force the index to be set. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.set_receiver_cache","title":"set_receiver_cache","text":"<pre><code>set_receiver_cache(rundir: Path) -&gt; None\n</code></pre> <p>Set the rundir for the detection model.</p> <p>Parameters:</p> Name Type Description Default <code>rundir</code> <code>Path</code> <p>The path to the rundir.</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.set_uncertainty","title":"set_uncertainty","text":"<pre><code>set_uncertainty(uncertainty: DetectionUncertainty) -&gt; None\n</code></pre> <p>Set detection uncertainty.</p> <p>Parameters:</p> Name Type Description Default <code>uncertainty</code> <code>DetectionUncertainty</code> <p>detection uncertainty</p> required"},{"location":"api/models/#qseek.models.detection.EventDetection.shift","title":"shift","text":"<pre><code>shift(east: float, north: float, elevation: float) -&gt; Self\n</code></pre> <p>Shift the location by the given offsets.</p> <p>Parameters:</p> Name Type Description Default <code>east</code> <code>float</code> <p>East offset in [m].</p> required <code>north</code> <code>float</code> <p>North offset in [m].</p> required <code>elevation</code> <code>float</code> <p>Elevation offset in [m].</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.shifted_origin","title":"shifted_origin","text":"<pre><code>shifted_origin() -&gt; Self\n</code></pre> <p>Shift the origin of the location to the effective lat/lon.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.snuffle","title":"snuffle","text":"<pre><code>snuffle(\n    squirrel: Squirrel,\n    restituted: bool | MeasurementUnit = False,\n) -&gt; None\n</code></pre> <p>Open snuffler for detection.</p> <p>Parameters:</p> Name Type Description Default <code>squirrel</code> <code>Squirrel</code> <p>The squirrel, holding the data</p> required <code>restituted</code> <code>bool</code> <p>Restitude the data. Defaults to False.</p> <code>False</code>"},{"location":"api/models/#qseek.models.detection.EventDetection.surface_distance_to","title":"surface_distance_to","text":"<pre><code>surface_distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute surface distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The surface distance in [m].</p>"},{"location":"api/models/#qseek.models.detection.EventDetection.update","title":"update  <code>async</code>","text":"<pre><code>update(rundir: Path) -&gt; None\n</code></pre> <p>Update detection in database.</p> <p>Doing this often requires a lot of I/O.</p>"},{"location":"api/octree/","title":"Octree","text":""},{"location":"api/octree/#qseek.octree.Octree","title":"qseek.octree.Octree  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Iterator[Node]</code>, <code>Sequence[Node]</code></p> <p>Config:</p> <ul> <li><code>ignored_types</code>: <code>(cached_property,)</code></li> </ul> <p>Fields:</p> <ul> <li> <code>location</code>                 (<code>Location</code>)             </li> <li> <code>root_node_size</code>                 (<code>PositiveFloat</code>)             </li> <li> <code>n_levels</code>                 (<code>int</code>)             </li> <li> <code>east_bounds</code>                 (<code>Range</code>)             </li> <li> <code>north_bounds</code>                 (<code>Range</code>)             </li> <li> <code>depth_bounds</code>                 (<code>Range</code>)             </li> <li> <code>_root_nodes</code>                 (<code>list[Node]</code>)             </li> <li> <code>_semblance</code>                 (<code>ndarray | None</code>)             </li> <li> <code>_cached_coordinates</code>                 (<code>dict[CoordSystem, ndarray]</code>)             </li> <li> <code>_nodes</code>                 (<code>list[Node]</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>check_reference</code>                 \u2192                   <code>location</code> </li> <li> <code>check_limits</code> </li> </ul>"},{"location":"api/octree/#qseek.octree.Octree.depth_bounds","title":"depth_bounds  <code>pydantic-field</code>","text":"<pre><code>depth_bounds: Range = Range(0 * KM, 20 * KM)\n</code></pre> <p>Depth bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.east_bounds","title":"east_bounds  <code>pydantic-field</code>","text":"<pre><code>east_bounds: Range = Range(-10 * KM, 10 * KM)\n</code></pre> <p>East bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.effective_depth_bounds","title":"effective_depth_bounds  <code>property</code>","text":"<pre><code>effective_depth_bounds: Range\n</code></pre> <p>Effective depth bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.leaf_nodes","title":"leaf_nodes  <code>cached</code> <code>property</code>","text":"<pre><code>leaf_nodes: list[Node]\n</code></pre> <p>Get all leaf nodes of the octree.</p> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of leaf nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.location","title":"location  <code>pydantic-field</code>","text":"<pre><code>location: Location = Location(lat=0.0, lon=0.0)\n</code></pre> <p>The geographical center of the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.n_leaf_nodes","title":"n_leaf_nodes  <code>cached</code> <code>property</code>","text":"<pre><code>n_leaf_nodes: int\n</code></pre> <p>Number of nodes in the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.n_levels","title":"n_levels  <code>pydantic-field</code>","text":"<pre><code>n_levels: int = 5\n</code></pre> <p>Number of levels in the octree, defining the final resolution of the detection. Default is 5.</p>"},{"location":"api/octree/#qseek.octree.Octree.n_nodes","title":"n_nodes  <code>cached</code> <code>property</code>","text":"<pre><code>n_nodes: int\n</code></pre> <p>Number of nodes in the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes: list[Node]\n</code></pre> <p>List of nodes in the octree.</p>"},{"location":"api/octree/#qseek.octree.Octree.north_bounds","title":"north_bounds  <code>pydantic-field</code>","text":"<pre><code>north_bounds: Range = Range(-10 * KM, 10 * KM)\n</code></pre> <p>North bounds of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.root_node_size","title":"root_node_size  <code>pydantic-field</code>","text":"<pre><code>root_node_size: PositiveFloat = 1 * KM\n</code></pre> <p>Size of the root node at the initial level (level 0) in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.semblance","title":"semblance  <code>property</code>","text":"<pre><code>semblance: ndarray\n</code></pre> <p>Returns the semblance values of all nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.volume","title":"volume  <code>property</code>","text":"<pre><code>volume: float\n</code></pre> <p>Volume of the octree in cubic meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.cached_bottom","title":"cached_bottom","text":"<pre><code>cached_bottom() -&gt; Self\n</code></pre> <p>Returns a copy of the octree refined to the cached bottom nodes.</p> <p>Raises:</p> Type Description <code>EnvironmentError</code> <p>If the octree has never been split.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Copy of the octree with cached bottom nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.check_limits","title":"check_limits  <code>pydantic-validator</code>","text":"<pre><code>check_limits() -&gt; Octree\n</code></pre> <p>Check that the size limits are valid.</p>"},{"location":"api/octree/#qseek.octree.Octree.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear the octree's cached data.</p>"},{"location":"api/octree/#qseek.octree.Octree.distances_stations","title":"distances_stations","text":"<pre><code>distances_stations(stations: StationInventory) -&gt; ndarray\n</code></pre> <p>Returns the 3D distances from all nodes to all stations.</p> <p>Parameters:</p> Name Type Description Default <code>stations</code> <code>Stations</code> <p>Stations to calculate distance to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Of shape (n-nodes, n-stations).</p>"},{"location":"api/octree/#qseek.octree.Octree.distances_stations_surface","title":"distances_stations_surface","text":"<pre><code>distances_stations_surface(\n    stations: StationInventory,\n) -&gt; ndarray\n</code></pre> <p>Returns the surface distance from all nodes to all stations.</p> <p>Parameters:</p> Name Type Description Default <code>stations</code> <code>Stations</code> <p>Stations to calculate distance to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Distances in shape (n-nodes, n-stations).</p>"},{"location":"api/octree/#qseek.octree.Octree.extent","title":"extent","text":"<pre><code>extent() -&gt; tuple[float, float, float]\n</code></pre> <p>Returns the extent of the octree.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: EW, NS and depth extent of the octree in meters.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_corners","title":"get_corners","text":"<pre><code>get_corners() -&gt; list[Location]\n</code></pre> <p>Get the corners of the octree.</p> <p>Returns:</p> Type Description <code>list[Location]</code> <p>list[Location]: List of locations.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_node_size","title":"get_node_size","text":"<pre><code>get_node_size(level: int = 0) -&gt; float\n</code></pre> <p>Get the size of a node at a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to get node size from.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size of the node.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes(indices: Iterable[int]) -&gt; list[Node]\n</code></pre> <p>Retrieves a list of nodes from the octree based on the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Iterable[int]</code> <p>The indices of the nodes to retrieve.</p> required <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: A list of nodes corresponding to the given indices.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_nodes_by_threshold","title":"get_nodes_by_threshold","text":"<pre><code>get_nodes_by_threshold(\n    semblance_threshold: float = 0.0,\n) -&gt; list[Node]\n</code></pre> <p>Get all nodes with a semblance above a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>semblance_threshold</code> <code>float</code> <p>Semblance threshold. Default is 0.0.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.get_nodes_level","title":"get_nodes_level","text":"<pre><code>get_nodes_level(level: int = 0) -&gt; list[Node]\n</code></pre> <p>Get all nodes at a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to get nodes from.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[Node]</code> <p>list[Node]: List of nodes.</p>"},{"location":"api/octree/#qseek.octree.Octree.interpolate_max_semblance","title":"interpolate_max_semblance  <code>async</code>","text":"<pre><code>interpolate_max_semblance(peak_node: Node) -&gt; Location\n</code></pre> <p>Interpolate the location of the maximum semblance value.</p> <p>This method calculates the location of the maximum semblance value by performing interpolation using surrounding nodes. It uses the scipy Rbf (Radial basis function) interpolation method to fit a smooth function to the given data points. The function is then minimized to find the location of the maximum value.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>Location of the maximum semblance value.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If no semblance values are set.</p>"},{"location":"api/octree/#qseek.octree.Octree.map_semblance","title":"map_semblance","text":"<pre><code>map_semblance(\n    semblance: ndarray, leaf_only: bool = True\n) -&gt; None\n</code></pre> <p>Maps semblance values to nodes.</p> <p>Parameters:</p> Name Type Description Default <code>semblance</code> <code>ndarray</code> <p>Of shape (n-nodes,).</p> required <code>leaf_only</code> <code>bool</code> <p>If True, only leaf nodes are mapped. Defaults to True.</p> <code>True</code>"},{"location":"api/octree/#qseek.octree.Octree.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Initialize octree. This method is called by the pydantic model.</p>"},{"location":"api/octree/#qseek.octree.Octree.reduce_axis","title":"reduce_axis","text":"<pre><code>reduce_axis(\n    surface: Literal[\"NE\", \"ED\", \"ND\"] = \"NE\",\n    max_level: int = -1,\n    accumulator: Callable[ndarray] = max,\n) -&gt; ndarray\n</code></pre> <p>Reduce the octree's nodes to the surface.</p> <p>Parameters:</p> Name Type Description Default <code>surface</code> <code>Literal['NE', 'ED', 'ND']</code> <p>Surface to reduce to. Defaults to \"NE\".</p> <code>'NE'</code> <code>max_level</code> <code>int</code> <p>Maximum level to reduce to. Defaults to -1.</p> <code>-1</code> <code>accumulator</code> <code>Callable</code> <p>Accumulator function. Defaults to np.max.</p> <code>max</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Of shape (n-nodes, 4) with columns (east, north, depth, value).</p>"},{"location":"api/octree/#qseek.octree.Octree.reset","title":"reset","text":"<pre><code>reset() -&gt; Self\n</code></pre> <p>Reset the octree to its initial state and return it.</p>"},{"location":"api/octree/#qseek.octree.Octree.save_pickle","title":"save_pickle","text":"<pre><code>save_pickle(filename: Path) -&gt; None\n</code></pre> <p>Save the octree to a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Filename to save to.</p> required"},{"location":"api/octree/#qseek.octree.Octree.set_level","title":"set_level","text":"<pre><code>set_level(level: int) -&gt; None\n</code></pre> <p>Set the octree to a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Level to set the octree to.</p> required"},{"location":"api/octree/#qseek.octree.Octree.smallest_node_size","title":"smallest_node_size","text":"<pre><code>smallest_node_size() -&gt; float\n</code></pre> <p>Returns the smallest possible node size.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Smallest possible node size.</p>"},{"location":"api/octree/#qseek.octree.Octree.total_number_nodes","title":"total_number_nodes","text":"<pre><code>total_number_nodes() -&gt; int\n</code></pre> <p>Returns the total number of nodes of all levels.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of nodes.</p>"},{"location":"api/overview/","title":"API Overview","text":"<p>The following pages give an overview of the Python API.</p>"},{"location":"api/ray_tracer/","title":"Ray Tracers","text":""},{"location":"api/ray_tracer/#qseek.tracers.base.RayTracer","title":"qseek.tracers.base.RayTracer  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>tracer</code>                 (<code>Literal['RayTracer']</code>)             </li> </ul>"},{"location":"api/ray_tracer/#qseek.tracers.base.RayTracer.get_travel_times","title":"get_travel_times  <code>async</code>","text":"<pre><code>get_travel_times(\n    phase: str,\n    nodes: Sequence[Node],\n    stations: Sequence[Station],\n) -&gt; ndarray\n</code></pre> <p>Get travel times for a phase from a source to a set of stations.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>str</code> <p>Phase name.</p> required <code>nodes</code> <code>Sequence[Node]</code> <p>Nodes to get traveltime for.</p> required <code>stations</code> <code>Sequence[Station]</code> <p>Stations to calculate travel times to.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Travel times in seconds.</p>"},{"location":"api/stations/","title":"Station Inventory","text":""},{"location":"api/stations/#qseek.models.station.Station","title":"qseek.models.station.Station  <code>pydantic-model</code>","text":"<p>               Bases: <code>Location</code></p> <p>Fields:</p> <ul> <li> <code>lat</code>                 (<code>float</code>)             </li> <li> <code>lon</code>                 (<code>float</code>)             </li> <li> <code>east_shift</code>                 (<code>float</code>)             </li> <li> <code>north_shift</code>                 (<code>float</code>)             </li> <li> <code>elevation</code>                 (<code>float</code>)             </li> <li> <code>depth</code>                 (<code>float</code>)             </li> <li> <code>_cached_lat_lon</code>                 (<code>tuple[float, float]</code>)             </li> <li> <code>_cached_origin</code>                 (<code>Location | None</code>)             </li> <li> <code>network</code>                 (<code>str</code>)             </li> <li> <code>station</code>                 (<code>str</code>)             </li> <li> <code>location</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/stations/#qseek.models.station.Station.depth","title":"depth  <code>pydantic-field</code>","text":"<pre><code>depth: float = 0.0\n</code></pre> <p>Depth in meters, positive is down.</p>"},{"location":"api/stations/#qseek.models.station.Station.east_shift","title":"east_shift  <code>pydantic-field</code>","text":"<pre><code>east_shift: float = 0.0\n</code></pre> <p>East shift towards geographical reference in meters.</p>"},{"location":"api/stations/#qseek.models.station.Station.effective_lat_lon","title":"effective_lat_lon  <code>property</code>","text":"<pre><code>effective_lat_lon: tuple[float, float]\n</code></pre> <p>Shift-corrected lat/lon pair of the location.</p>"},{"location":"api/stations/#qseek.models.station.Station.elevation","title":"elevation  <code>pydantic-field</code>","text":"<pre><code>elevation: float = 0.0\n</code></pre> <p>Elevation in meters.</p>"},{"location":"api/stations/#qseek.models.station.Station.lat","title":"lat  <code>pydantic-field</code>","text":"<pre><code>lat: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/stations/#qseek.models.station.Station.location","title":"location  <code>pydantic-field</code>","text":"<pre><code>location: str = ''\n</code></pre> <p>Location code</p>"},{"location":"api/stations/#qseek.models.station.Station.lon","title":"lon  <code>pydantic-field</code>","text":"<pre><code>lon: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/stations/#qseek.models.station.Station.network","title":"network  <code>pydantic-field</code>","text":"<pre><code>network: str\n</code></pre> <p>Seismic network code</p>"},{"location":"api/stations/#qseek.models.station.Station.north_shift","title":"north_shift  <code>pydantic-field</code>","text":"<pre><code>north_shift: float = 0.0\n</code></pre> <p>North shift towards geographical reference in meters.</p>"},{"location":"api/stations/#qseek.models.station.Station.nsl","title":"nsl  <code>property</code>","text":"<pre><code>nsl: _NSL\n</code></pre> <p>Network Station Location code as tuple.</p> <p>Returns:</p> Type Description <code>_NSL</code> <p>tuple[str, str, str]: Network, Station, Location</p>"},{"location":"api/stations/#qseek.models.station.Station.station","title":"station  <code>pydantic-field</code>","text":"<pre><code>station: str\n</code></pre> <p>Station code</p>"},{"location":"api/stations/#qseek.models.station.Station.as_wkt","title":"as_wkt","text":"<pre><code>as_wkt() -&gt; str\n</code></pre> <p>Return the location as WKT string.</p>"},{"location":"api/stations/#qseek.models.station.Station.azimuth_to","title":"azimuth_to","text":"<pre><code>azimuth_to(other: Location) -&gt; float\n</code></pre> <p>Compute azimuth [\u00b0] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The azimuth in [\u00b0].</p>"},{"location":"api/stations/#qseek.models.station.Station.distance_to","title":"distance_to","text":"<pre><code>distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute 3-dimensional distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance in [m].</p>"},{"location":"api/stations/#qseek.models.station.Station.offset_from","title":"offset_from","text":"<pre><code>offset_from(other: Location) -&gt; tuple[float, float, float]\n</code></pre> <p>Return offset vector (east, north, depth) from other location in [m].</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The offset vector.</p>"},{"location":"api/stations/#qseek.models.station.Station.origin","title":"origin","text":"<pre><code>origin() -&gt; Location\n</code></pre> <p>Get the origin location.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>The origin location.</p>"},{"location":"api/stations/#qseek.models.station.Station.shift","title":"shift","text":"<pre><code>shift(east: float, north: float, elevation: float) -&gt; Self\n</code></pre> <p>Shift the location by the given offsets.</p> <p>Parameters:</p> Name Type Description Default <code>east</code> <code>float</code> <p>East offset in [m].</p> required <code>north</code> <code>float</code> <p>North offset in [m].</p> required <code>elevation</code> <code>float</code> <p>Elevation offset in [m].</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/stations/#qseek.models.station.Station.shifted_origin","title":"shifted_origin","text":"<pre><code>shifted_origin() -&gt; Self\n</code></pre> <p>Shift the origin of the location to the effective lat/lon.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The shifted location.</p>"},{"location":"api/stations/#qseek.models.station.Station.surface_distance_to","title":"surface_distance_to","text":"<pre><code>surface_distance_to(other: Location) -&gt; float\n</code></pre> <p>Compute surface distance [m] to other location object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Location</code> <p>The other location.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The surface distance in [m].</p>"},{"location":"api/stations/#qseek.models.station.StationInventory","title":"qseek.models.station.StationInventory  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>pyrocko_station_yamls</code>                 (<code>list[FilePath]</code>)             </li> <li> <code>station_xmls</code>                 (<code>list[FilePath | DirectoryPath]</code>)             </li> <li> <code>blacklist</code>                 (<code>Blacklist</code>)             </li> <li> <code>stations</code>                 (<code>list[Station]</code>)             </li> <li> <code>max_distance</code>                 (<code>PositiveFloat | None</code>)             </li> </ul>"},{"location":"api/stations/#qseek.models.station.StationInventory.blacklist","title":"blacklist  <code>pydantic-field</code>","text":"<pre><code>blacklist: Blacklist = Blacklist()\n</code></pre> <p>Blacklist stations and exclude from detecion. Format is <code>['NET.STA.LOC', ...]</code>.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.max_distance","title":"max_distance  <code>pydantic-field</code>","text":"<pre><code>max_distance: PositiveFloat | None = None\n</code></pre> <p>Maximum distance in meters from the centroid location to include stations for detection. If None, all stations are included.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.n_networks","title":"n_networks  <code>property</code>","text":"<pre><code>n_networks: int\n</code></pre> <p>Number of stations.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.n_stations","title":"n_stations  <code>property</code>","text":"<pre><code>n_stations: int\n</code></pre> <p>Number of stations.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.pyrocko_station_yamls","title":"pyrocko_station_yamls  <code>pydantic-field</code>","text":"<pre><code>pyrocko_station_yamls: list[FilePath] = []\n</code></pre> <p>List of Pyrocko station YAML files.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.station_xmls","title":"station_xmls  <code>pydantic-field</code>","text":"<pre><code>station_xmls: list[FilePath | DirectoryPath] = []\n</code></pre> <p>List of StationXML files or directories containing StationXML (.xml) files.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.as_pyrocko_stations","title":"as_pyrocko_stations","text":"<pre><code>as_pyrocko_stations() -&gt; list[Station]\n</code></pre> <p>Convert the stations to PyrockoStation objects.</p> <p>Returns:</p> Type Description <code>list[Station]</code> <p>A list of PyrockoStation objects.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.export_csv","title":"export_csv","text":"<pre><code>export_csv(filename: Path) -&gt; None\n</code></pre> <p>Dump stations to CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Path to CSV file.</p> required"},{"location":"api/stations/#qseek.models.station.StationInventory.export_pyrocko_stations","title":"export_pyrocko_stations","text":"<pre><code>export_pyrocko_stations(filename: Path) -&gt; None\n</code></pre> <p>Dump stations to pyrocko station yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Path to yaml file.</p> required"},{"location":"api/stations/#qseek.models.station.StationInventory.filter_stations","title":"filter_stations","text":"<pre><code>filter_stations(nsls: Iterable[NSL]) -&gt; None\n</code></pre> <p>Filter stations by NSL codes.</p> <p>All stations not in the provided NSL codes are removed from the inventory.</p> <p>Parameters:</p> Name Type Description Default <code>nsls</code> <code>list[NSL]</code> <p>List of NSL codes to keep.</p> required"},{"location":"api/stations/#qseek.models.station.StationInventory.get_centroid","title":"get_centroid","text":"<pre><code>get_centroid() -&gt; Location\n</code></pre> <p>Get centroid location from all stations.</p> <p>Returns:</p> Name Type Description <code>Location</code> <code>Location</code> <p>Centroid Location.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.get_nsls","title":"get_nsls","text":"<pre><code>get_nsls() -&gt; tuple[NSL, ...]\n</code></pre> <p>Get all NSL codes from all stations.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.mean_interstation_distance","title":"mean_interstation_distance","text":"<pre><code>mean_interstation_distance() -&gt; float\n</code></pre> <p>Calculate the mean interstation distance.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean interstation distance in meters.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.prepare","title":"prepare","text":"<pre><code>prepare(location: Location) -&gt; None\n</code></pre> <p>Prepare the station inventory.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>Location to calculate distances from.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no stations are available after preparation.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.sanitize_stations","title":"sanitize_stations","text":"<pre><code>sanitize_stations() -&gt; None\n</code></pre> <p>Remove stations with bad coordinates or duplicates.</p>"},{"location":"api/stations/#qseek.models.station.StationInventory.select_from_traces","title":"select_from_traces","text":"<pre><code>select_from_traces(\n    traces: Sequence[Trace],\n) -&gt; list[Station]\n</code></pre> <p>Select stations by NSL code.</p> <p>Stations are not unique and are ordered by the input traces.</p> <p>Parameters:</p> Name Type Description Default <code>traces</code> <code>Iterable[Trace]</code> <p>Iterable of Pyrocko Traces</p> required <p>Returns:</p> Name Type Description <code>Stations</code> <code>list[Station]</code> <p>Containing only selected stations.</p>"},{"location":"api/stations/#qseek.models.station.StationList","title":"qseek.models.station.StationList","text":"<p>               Bases: <code>Sequence[Station]</code></p> <p>A frozen station list.</p> <p>Methods:</p> Name Description <code>get_index</code> <p>Get the index of a station by its NSL code.</p> <code>get_indices</code> <p>Get the indices of stations by their NSL codes.</p> <code>get_indices_by_nsl</code> <p>Get the indices of stations by their NSL codes.</p>"},{"location":"api/stations/#qseek.models.station.StationList.get_index","title":"get_index","text":"<pre><code>get_index(nsl: NSL) -&gt; int\n</code></pre> <p>Get the index of a station by its NSL code.</p> <p>Parameters:</p> Name Type Description Default <code>nsl</code> <code>NSL</code> <p>NSL code of the station.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the station.</p>"},{"location":"api/stations/#qseek.models.station.StationList.get_indices","title":"get_indices","text":"<pre><code>get_indices(stations: Sequence[Station]) -&gt; ndarray\n</code></pre> <p>Get the indices of stations by their NSL codes.</p> <p>Parameters:</p> Name Type Description Default <code>stations</code> <code>Iterable[Station]</code> <p>Iterable of stations.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Indices of the stations.</p>"},{"location":"api/stations/#qseek.models.station.StationList.get_indices_by_nsl","title":"get_indices_by_nsl","text":"<pre><code>get_indices_by_nsl(nsls: Sequence[NSL]) -&gt; ndarray\n</code></pre> <p>Get the indices of stations by their NSL codes.</p> <p>Parameters:</p> Name Type Description Default <code>nsls</code> <code>Iterable[NSL]</code> <p>Iterable of NSL codes of the stations.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Indices of the stations.</p>"},{"location":"api/utils/","title":"Utils","text":""},{"location":"api/utils/#qseek.utils.Range","title":"qseek.utils.Range  <code>module-attribute</code>","text":"<pre><code>Range = Annotated[_Range, AfterValidator(_range_validator)]\n</code></pre>"},{"location":"api/utils/#qseek.utils._Range","title":"qseek.utils._Range","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Methods:</p> Name Description <code>from_list</code> <p>Create a Range object from a numpy array.</p> <code>inside</code> <p>Check if a value is inside the range.</p> <code>width</code> <p>Calculate the width of the range.</p>"},{"location":"api/utils/#qseek.utils._Range.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(array: ndarray | list[float]) -&gt; _Range\n</code></pre> <p>Create a Range object from a numpy array.</p> <ul> <li>array: numpy.ndarray     The array from which to create the Range object.</li> </ul> <p>Returns: - _Range: The created Range object.</p>"},{"location":"api/utils/#qseek.utils._Range.inside","title":"inside","text":"<pre><code>inside(value: float) -&gt; bool\n</code></pre> <p>Check if a value is inside the range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is inside the range, False otherwise.</p>"},{"location":"api/utils/#qseek.utils._Range.width","title":"width","text":"<pre><code>width() -&gt; float\n</code></pre> <p>Calculate the width of the range.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The width of the range.</p>"},{"location":"components/configuration/","title":"Qseek Configuration","text":"<p>At center is a JSON configuration file which is parsed by Pydantic. The following pages will detail how to setup this JSON file for the search.</p> <p>See the getting started guide for a brief introduction into the CLI.</p> <p>General configuration conventions are outlines in this guide as well.</p> <p>Create a new config file.</p> Using the CLI<pre><code>qseek config\n</code></pre>"},{"location":"components/configuration/#the-search","title":"The Search","text":"<p>The search configuration. This is the entrypoint for the EQ detection and localisation. More information on the submodules (e.g. Octree, Data Provider and other) can be found on subpages in the navigation.</p> <p></p>"},{"location":"components/configuration/#exec-3--search-module","title":"Search Module","text":"Config SearchJSON  <code>stations</code> <p>Station inventory from StationXML or Pyrocko Station YAML.</p> <code>data_provider</code> <p>Data provider for waveform data.</p> <code>pre_processing</code> <p>Pre-processing steps for waveform data.</p> <code>octree</code> <p>Octree volume for the search.</p> <code>image_functions</code> <p>Image functions for waveform processing and phase on-set detection.</p> <code>ray_tracers</code> <p>List of ray tracers for travel time calculation.</p> <code>distance_weights</code> <p>Spatial weights for distance weighting.</p> <code>station_corrections</code> <p>Apply station corrections extracted from a previous run or a path to a directory with station correction files.</p> <code>magnitudes</code> <p>Magnitude calculators to use.</p> <code>features</code> <p>Event features to extract.</p> <code>semblance_sampling_rate</code>: <code>10 | 20 | 25 | 50 | 100 | 200 | 400</code> <p>Sampling rate for the semblance image function. Choose from <code>10, 20, 25, 50, 100, 200 or 400</code> Hz.</p> <code>detection_threshold</code> <p>Detection threshold for semblance.</p> <code>pick_confidence_threshold</code>: <code>0.2</code> <p>Confidence threshold for picking.</p> <code>min_stations</code>: <code>3</code> <p>Minimum number of stations required for detection and localization.</p> <code>ignore_boundary</code>: <code>False | with_surface | without_surface</code> <p>Ignore events that are inside the first root node layer of the octree. If <code>with_surface</code>, all events inside the boundaries of the volume are absorbed. If <code>without_surface</code>, events at the surface are not absorbed.</p> <code>ignore_boundary_width</code> <p>Width of the absorbing boundary around the octree volume. If 'octree' the width is set to the root node size of the octree.</p> <code>node_interpolation</code>: <code>True</code> <p>Interpolate intranode locations for detected events using radial basis functions. If <code>False</code>, the node center location is used for the event hypocentre.</p> <code>detection_blinding</code> <p>Blinding time in seconds before and after the detection peak. This is used to avoid detecting the same event multiple times. Default is 2 seconds.</p> <code>window_length</code> <p>Window length for processing. Smaller window size will be less RAM consuming. Default is 5 minutes.</p> <code>n_threads</code> <p>Number of threads for stacking and migration. <code>'auto'</code> will use the maximum number of cores and leaves resources for I/O and other work. <code>0</code> uses all available cores.</p> <code>save_images</code>: <code>False</code> <p>Save annotation images to disk for debugging and analysis.</p> JSON for Search<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"pyrocko_station_yamls\": [],\n    \"station_xmls\": [],\n    \"blacklist\": [],\n    \"stations\": [],\n    \"max_distance\": null\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"channel_selector\": null,\n    \"environment\": null,\n    \"persistent\": null,\n    \"waveform_dirs\": [\n      \"data\"\n    ],\n    \"start_time\": null,\n    \"end_time\": null,\n    \"n_threads\": 8,\n    \"watch_waveforms\": false,\n    \"queue_size\": 16\n  },\n  \"pre_processing\": [\n    {\n      \"process\": \"downsample\",\n      \"stations\": [],\n      \"sampling_frequency\": 100.0\n    },\n    {\n      \"process\": \"bandpass\",\n      \"stations\": [],\n      \"corners\": 4,\n      \"bandpass\": [\n        0.5,\n        30.0\n      ],\n      \"demean\": true,\n      \"zero_phase\": true\n    }\n  ],\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 1000.0,\n    \"n_levels\": 5,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ]\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"SeisBench\",\n      \"model\": \"PhaseNet\",\n      \"pretrained\": \"original\",\n      \"window_overlap_samples\": 1500,\n      \"torch_use_cuda\": true,\n      \"torch_cpu_threads\": 4,\n      \"batch_size\": 128,\n      \"stack_method\": \"avg\",\n      \"sampling_rate\": 100.0,\n      \"phase_map\": {\n        \"P\": \"cake:P\",\n        \"S\": \"cake:S\"\n      },\n      \"weights\": {\n        \"P\": 1.0,\n        \"S\": 1.0\n      }\n    }\n  ],\n  \"ray_tracers\": [\n    {\n      \"tracer\": \"CakeTracer\",\n      \"phases\": {\n        \"cake:P\": {\n          \"definition\": \"P,p\"\n        },\n        \"cake:S\": {\n          \"definition\": \"S,s\"\n        }\n      },\n      \"earthmodel\": {\n        \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      }\n    },\n    {\n      \"tracer\": \"ConstantVelocityTracer\",\n      \"phase\": \"constant:P\",\n      \"velocity\": 5000.0\n    },\n    {\n      \"tracer\": \"FastMarching\",\n      \"velocity_model\": {\n        \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n        \"format\": \"nd\",\n        \"crust2_profile\": \"\",\n        \"raw_file_data\": null\n      },\n      \"interpolation_method\": \"linear\",\n      \"nthreads\": 0,\n      \"implementation\": \"pyrocko\",\n      \"phases\": [\n        \"fm:P\",\n        \"fm:S\"\n      ]\n    }\n  ],\n  \"distance_weights\": {\n    \"distance_taper\": \"mean_interstation\",\n    \"required_closest_stations\": 4,\n    \"waterlevel\": 0.0\n  },\n  \"station_corrections\": null,\n  \"magnitudes\": [],\n  \"features\": [],\n  \"semblance_sampling_rate\": 100,\n  \"detection_threshold\": \"MAD\",\n  \"pick_confidence_threshold\": 0.2,\n  \"min_stations\": 3,\n  \"ignore_boundary\": false,\n  \"ignore_boundary_width\": \"root_node_size\",\n  \"node_interpolation\": true,\n  \"detection_blinding\": \"PT1S\",\n  \"window_length\": \"PT5M\",\n  \"n_threads\": \"auto\",\n  \"save_images\": false,\n  \"created\": \"2026-01-10T19:05:39.360793Z\"\n}\n</code></pre>"},{"location":"components/configuration/#minimal-config","title":"Minimal Config","text":"<p>This is a minimal config which can used to start a Qseek search.</p> Minimal Qseek Config<pre><code>{\n  \"project_dir\": \".\",\n  \"stations\": {\n    \"station_xmls\": [],\n    \"pyrocko_station_yamls\": [\"search/pyrocko-stations.yaml\"],\n  },\n  \"data_provider\": {\n    \"provider\": \"PyrockoSquirrel\",\n    \"environment\": \".\",\n    \"waveform_dirs\": [\"data/\"],\n  },\n  \"octree\": {\n    \"location\": {\n      \"lat\": 0.0,\n      \"lon\": 0.0,\n      \"east_shift\": 0.0,\n      \"north_shift\": 0.0,\n      \"elevation\": 0.0,\n      \"depth\": 0.0\n    },\n    \"root_node_size\": 2000.0,\n    \"n_levels\": 3,\n    \"east_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"north_bounds\": [\n      -10000.0,\n      10000.0\n    ],\n    \"depth_bounds\": [\n      0.0,\n      20000.0\n    ],\n    \"absorbing_boundary\": 1000.0\n  },\n  \"image_functions\": [\n    {\n      \"image\": \"PhaseNet\",\n      \"model\": \"ethz\",\n      \"torch_use_cuda\": false,\n      \"phase_map\": {\n        \"P\": \"constant:P\",\n        \"S\": \"constant:S\"\n      },\n    }\n  ],\n  \"ray_tracers\": [\n    {\n    \"tracer\": \"ConstantVelocityTracer\",\n    \"phase\": \"constant:P\",\n    \"velocity\": 5000.0\n    }\n  ],\n  \"station_corrections\": {},\n  \"event_features\": [],\n  \"sampling_rate\": 100,\n  \"detection_threshold\": 0.05,\n  \"detection_blinding\": \"PT2S\",\n  \"node_split_threshold\": 0.9,\n  \"window_length\": \"PT300S\",\n  \"n_threads_parstack\": 0,\n  \"n_threads_argmax\": 4,\n}\n</code></pre>"},{"location":"components/configuration/#structure","title":"Structure","text":"<p>Structure of the search and optimisation of the octree, which is focusing in on seismic energy.</p> <pre><code>%%{init: {'theme': 'neutral', 'themeVariables': { 'fontSize': '14pt'}}}%%\nflowchart LR\n    subgraph Seismic Data\n        waveforms([\"fa:fa-water Seismic\\nWaveforms\"])\n        image{{\"fa:fa-bolt Waveform Image Function\\nPhaseNet / EQTransformer / ...\"}}\n        waveforms --&gt; image\n    end\n    subgraph Travel Time Model\n        travelTimes([\"fa:fa-layer-group Seismic\\nTravel Time Model\"])\n        stationCorrections{{\"fab:fa-arrows-to-dot Station Corrections\\nSST / SSST\"}}\n        travelTimes --&gt;|add| stationCorrections\n    end\n    subgraph Stacking and Migration\n        octree[\"fa:fa-cubes\\nOctree Grid\"]\n        detection[\"fa:fa-bullseye Detection\\nand Localisation\"]\n    end\n    featureExtraction(\"fa:fa-info Extract Event Features\\nMagnitudes, Ground Motion, ...\")\n    correctionExtraction(\"fa:fa-stopwatch Extract\\nStation Corrections\")\n\n    image --&gt; octree\n    stationCorrections --&gt; octree\n    detection -.-&gt;|\"fa:fa-cube\\nRefine\"| octree\n    octree --&gt; detection\n    detection --&gt; featureExtraction &amp; correctionExtraction\n</code></pre> <p>Building blocks of the specific stacking and migration method for earthquake detection, localisation and characterisation.</p>"},{"location":"components/distance_weighting/","title":"Station Distance Weighting","text":"<p>Station distance weights are used to give stations close to a node higher weight as it contributes more accurate information about the event's hypocenter. Station nodes are calculated for every node and station in the search volume.</p> <p>Tip</p> <p>Station weights play a crucial role for successful detection and location of events. While the default parameters are tuned for local and regional networks. The <code>distance_taper</code> and <code>waterlevel</code> may have to be tuned for different layouts.</p> <p></p> <p>Distance weights beteen a single node and stations. Shown here is the station weight and cummulative weight for the whole network. With three tuneable parameters: (1) Required closest stations, (2) taper distance and (3) waterlevel.</p> <p></p>"},{"location":"components/distance_weighting/#exec-4--distanceweights-module","title":"DistanceWeights Module","text":"Config DistanceWeightsJSON  <code>distance_taper</code> <p>Taper distance for the Gaussian weighting function in meters. 'mean_interstation' uses twice the mean interstation distance for the radius. Default is 'mean_interstation'.</p> <code>required_closest_stations</code>: <code>4</code> <p>Number of stations to assign full weight in the spatial weighting function, only more distant stations are tapered with a Gaussian decay. This ensures that the closest N stations have an equal and the highest contribution to the detection and localization. Default is 4.</p> <code>waterlevel</code>: <code>0.0</code> <p>Stations outside the taper are lifted by this fraction. Default is 0.0.</p> JSON for DistanceWeights<pre><code>{\n  \"distance_taper\": \"mean_interstation\",\n  \"required_closest_stations\": 4,\n  \"waterlevel\": 0.0\n}\n</code></pre>"},{"location":"components/general/","title":"General Settings","text":""},{"location":"components/general/#paths","title":"Paths","text":"<p>Paths can be relative to the location of the config file or absolute. File paths and directory paths are checked whether they exist.</p>"},{"location":"components/general/#date-and-time","title":"Date and Time","text":"<p>Serialisation of time, dates and date times and durations follow ISO8601 format with timezone information. E.g. <code>2023-10-28T01:21:21.003Z</code>.</p> <p>Duration are serialized like <code>PT600S</code>, this example shows a duration of 600 seconds, 10 minutes.</p> <p>!!!+ note Timezone Info     All datetimes are timezone aware! For UTC this is the <code>Z</code> or <code>+00:00</code> suffix.     Also other offsets can be defined according to ISO8601.</p> Example of datetimes and durations<pre><code>{\n    \"start_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"end_time\": \"2023-10-28T01:21:21.003+00:00\",\n    \"duration\": \"PT600S\"\n}\n</code></pre>"},{"location":"components/general/#locations","title":"Locations","text":"<p>Geographic locations have a geographic reference and a relative shift in meters. The octree or velocity models are referenced using Location objects.</p> <p>All distances, depths and elevations are given in meters.</p> <p></p>"},{"location":"components/general/#exec-5--location-module","title":"Location Module","text":"Config LocationJSON  <code>lat</code>: <code>PydanticUndefined</code> <p>Latitude in degrees.</p> <code>lon</code>: <code>PydanticUndefined</code> <p>Longitude in degrees.</p> <code>east_shift</code>: <code>0.0</code> <p>East shift towards geographical reference in meters.</p> <code>north_shift</code>: <code>0.0</code> <p>North shift towards geographical reference in meters.</p> <code>elevation</code>: <code>0.0</code> <p>Elevation in meters.</p> <code>depth</code>: <code>0.0</code> <p>Depth in meters, positive is down.</p> JSON for Location<pre><code>{\n  \"lat\": 52.3825,\n  \"lon\": 13.0644,\n  \"east_shift\": 0.0,\n  \"north_shift\": 0.0,\n  \"elevation\": 0.0,\n  \"depth\": 0.0\n}\n</code></pre>"},{"location":"components/image_function/","title":"Phase Arrival Image Function","text":"<p>For image functions this version of Qseek relies heavily on machine learning phase-arrival pickers delivered by SeisBench.</p>"},{"location":"components/image_function/#seisbench-image-function","title":"SeisBench Image Function","text":"<p>SeisBench offers access to a variety of machine learning phase pickers pre-trained on various data sets.</p> <p>Citation PhaseNet</p> <p>Zhu, Weiqiang, and Gregory C. Beroza. \"PhaseNet: A Deep-Neural-Network-Based Seismic Arrival Time Picking Method.\" arXiv preprint arXiv:1803.03211 (2018).</p> <p></p>"},{"location":"components/image_function/#exec-6--seisbench-module","title":"SeisBench Module","text":"<p>PhaseNet image function. For more details see SeisBench documentation.</p> Config SeisBench <code>model</code>: <code>PhaseNet | EQTransformer | OBSTransformer | LFEDetect | GPD</code> <p>The model to use for the image function. Currently supported models are <code>PhaseNet</code>, <code>EQTransformer</code>, <code>GPD</code>, <code>OBSTransformer</code>, <code>LFEDetect</code>.</p> <code>pretrained</code> <p>SeisBench pre-trained model to use. Choose from the available pre-trained models or provide a path to a custom model .json file. For more details see SeisBench documentation.</p> <p>Available models are:cascadia, cms, diting, dummy, ethz, geofon, instance, iquique, jcms, jcs, jms, lendb, mexico, nankai, neic, obs, obst2024, original, original_nonconservative, san_andreas, scedc, stead, volpick</p> <pre><code>**`window_overlap_samples`: `1500`**\n\n:   Window overlap in samples.\n\n**`torch_use_cuda`**\n\n:   Use CUDA for inference. If `True` use default device, if `int` use the specified device.\n\n**`torch_cpu_threads`: `4`**\n\n:   Number of CPU threads to use if only CPU is used.\n\n**`batch_size`: `128`**\n\n:   Batch size for inference, larger values can improve performance.\n\n**`stack_method`: `avg | max`**\n\n:   Method to stack the overlaping blocks internally. Choose from `avg` and `max`.\n\n**`sampling_rate`: `100.0`**\n\n:   Upscale input by factor. This augments the input data from e.g. 100 Hz to 50 Hz (factor: `2`). Can be useful for high-frequency microseismic events.\n\n**`phase_map`**\n\n:   Phase mapping from SeisBench PhaseNet to Qseek travel time phases.\n\n**`weights`**\n\n:   Weights for each phase.\n</code></pre> JSON  JSON for SeisBench<pre><code>{\n  \"image\": \"SeisBench\",\n  \"model\": \"PhaseNet\",\n  \"pretrained\": \"original\",\n  \"window_overlap_samples\": 1500,\n  \"torch_use_cuda\": true,\n  \"torch_cpu_threads\": 4,\n  \"batch_size\": 128,\n  \"stack_method\": \"avg\",\n  \"sampling_rate\": 100.0,\n  \"phase_map\": {\n    \"P\": \"cake:P\",\n    \"S\": \"cake:S\"\n  },\n  \"weights\": {\n    \"P\": 1.0,\n    \"S\": 1.0\n  }\n}\n</code></pre>"},{"location":"components/magnitudes/","title":"Earthquake Magnitude Calculation","text":"<p>Qseek supports earthquake magnitude calculation as Local Magnitudes in different attenuation models and Moment Magnitudes derived from forward-modelled attenuation curves.</p>"},{"location":"components/magnitudes/#local-magnitude","title":"Local Magnitude","text":"<p>Local magnitude calculation relies on a tuned attenuation model.</p> <p></p>"},{"location":"components/magnitudes/#exec-7--localmagnitudeextractor-module","title":"LocalMagnitudeExtractor Module","text":"<p>Local magnitude calculator for different regional models.</p> Config LocalMagnitudeExtractorJSON  <code>noise_window</code>: <code>5.0</code> <p>Waveforms to extract before P phase arrival. The noise amplitude is extracted from before the P phase arrival, with 0.5 s padding.</p> <code>seconds_after</code>: <code>4.0</code> <p>Waveforms to extract after S phase arrival.</p> <code>taper_seconds</code>: <code>10.0</code> <p>Seconds tapering before and after the extraction window. The taper stabalizes the restitution and is cut off from the traces before the analysis.</p> <code>min_signal_noise_ratio</code>: <code>1.5</code> <p>Minimum signal-to-noise ratio for the local magnitude estimation. The noise amplitude is extracted from before the P phase arrival, with 0.5 s padding.</p> <code>max_station_std</code>: <code>3.0</code> <p>Maximum standard deviation of the station magnitudes to include in the local magnitude estimation.</p> <code>model</code>: <code>webnet-western-bohemia | southern-california | central-california | iaspei-southern-california | eastern-north-america | albania | south-west-germany | south-australia | norway-fennoscandia | iceland-askja | iceland-bardabunga | iceland-askja-bardabunga-combined | iceland-reykjanes | azores | argentina-volcanoes | netherlands-groningen</code> <p>The amplitude attenuation model to use for calculating the local magnitude.</p> <code>export_mseed</code> <p>Path to export the processed mseed traces to.</p> JSON for LocalMagnitudeExtractor<pre><code>{\n  \"magnitude\": \"LocalMagnitude\",\n  \"noise_window\": 5.0,\n  \"seconds_after\": 4.0,\n  \"taper_seconds\": 10.0,\n  \"min_signal_noise_ratio\": 1.5,\n  \"max_station_std\": 3.0,\n  \"model\": \"iaspei-southern-california\",\n  \"export_mseed\": null\n}\n</code></pre>"},{"location":"components/magnitudes/#moment-magnitude","title":"Moment Magnitude","text":"<p>Based on forward-modelled attenuation curves using Pyrocko-GF. For more information on the method see Dahm et al., 2024.</p> <p></p>"},{"location":"components/magnitudes/#exec-8--momentmagnitudeextractor-module","title":"MomentMagnitudeExtractor Module","text":"<p>Moment magnitude calculator from peak amplitudes.</p> Config MomentMagnitudeExtractorJSON  <code>noise_window</code>: <code>5.0</code> <p>Waveforms to extract before P phase arrival. The noise amplitude is extracted from before the P phase arrival, with a one second padding.</p> <code>seconds_after</code>: <code>4.0</code> <p>Waveforms to extract after S phase arrival.</p> <code>taper_seconds</code>: <code>10.0</code> <p>Seconds tapering before and after the extraction window. The taper stabalizes the restitution and is cut off from the traces before the analysis.</p> <code>min_signal_noise_ratio</code>: <code>1.5</code> <p>Minimum signal-to-noise ratio for the magnitude estimation. The noise amplitude is extracted from before the P phase arrival, with 0.5 s padding.</p> <code>max_station_std</code>: <code>3.0</code> <p>Maximum standard deviation of the station magnitudes to include in the local magnitude estimation.</p> <code>gf_store_dirs</code> <p>The directories of the Pyrocko GF stores.</p> <code>export_mseed</code> <p>Path to export the processed mseed traces to.</p> <code>models</code> <p>The peak amplitude models to use.</p> JSON for MomentMagnitudeExtractor<pre><code>{\n  \"magnitude\": \"MomentMagnitude\",\n  \"noise_window\": 5.0,\n  \"seconds_after\": 4.0,\n  \"taper_seconds\": 10.0,\n  \"min_signal_noise_ratio\": 1.5,\n  \"max_station_std\": 3.0,\n  \"gf_store_dirs\": [\n    \".\"\n  ],\n  \"export_mseed\": null,\n  \"models\": [\n    {\n      \"gf_store_id\": \"moment_magnitude\",\n      \"quantity\": \"displacement\",\n      \"frequency_range\": [\n        2.0,\n        20.0\n      ],\n      \"max_distance\": 100000.0,\n      \"source_depth_delta\": 1000.0,\n      \"reference_magnitude\": 1.0,\n      \"rupture_velocities\": [\n        0.8,\n        0.9\n      ],\n      \"stress_drop\": [\n        1000000.0,\n        10000000.0\n      ],\n      \"gf_interpolation\": \"multilinear\",\n      \"nsl_id\": null,\n      \"peak_amplitude\": \"absolute\",\n      \"station_epicentral_range\": [\n        1000.0,\n        100000.0\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"components/octree/","title":"Octree Search Volume","text":"<p>A 3D space is searched for sources of seismic energy. Qseek created an octree structure which is iteratively refined when energy is detected, to focus on the source' location. This speeds up the search and improves the resolution of the localisations.</p> <p></p> <p>Surface projection of the refined octree focusing on the seismic source region. In this example four levels of refinement are can be seen, refining the 3D octree from the initial 4000 nodes to 8823 nodes.</p> <p></p>"},{"location":"components/octree/#exec-9--octree-module","title":"Octree Module","text":"Config OctreeJSON  <code>location</code> <p>The geographical center of the octree.</p> <code>root_node_size</code>: <code>1000.0</code> <p>Size of the root node at the initial level (level 0) in meters.</p> <code>n_levels</code>: <code>5</code> <p>Number of levels in the octree, defining the final resolution of the detection. Default is 5.</p> <code>east_bounds</code> <p>East bounds of the octree in meters.</p> <code>north_bounds</code> <p>North bounds of the octree in meters.</p> <code>depth_bounds</code> <p>Depth bounds of the octree in meters.</p> JSON for Octree<pre><code>{\n  \"location\": {\n    \"lat\": 0.0,\n    \"lon\": 0.0,\n    \"east_shift\": 0.0,\n    \"north_shift\": 0.0,\n    \"elevation\": 0.0,\n    \"depth\": 0.0\n  },\n  \"root_node_size\": 1000.0,\n  \"n_levels\": 5,\n  \"east_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"north_bounds\": [\n    -10000.0,\n    10000.0\n  ],\n  \"depth_bounds\": [\n    0.0,\n    20000.0\n  ]\n}\n</code></pre>"},{"location":"components/ray_tracer/","title":"Ray Tracers","text":"<p>The calculation of seismic travel times is a cornerstone for the migration and stacking approach. Qseek supports different ray tracers for travel time calculation, which can be adapted for different geological settings.</p>"},{"location":"components/ray_tracer/#constant-velocity","title":"Constant Velocity","text":"<p>The constant velocity models is trivial and follows:</p> \\[ t_{P} = \\frac{d}{v_P} \\] <p>This module is used for simple use cases and cross-referencing testing.</p> <p></p>"},{"location":"components/ray_tracer/#exec-10--constantvelocitytracer-module","title":"ConstantVelocityTracer Module","text":"<p>Travel time tracer with a constant velocity.</p> Config ConstantVelocityTracerJSON  <code>phase</code>: <code>constant:P</code> <p>Name of the phase.</p> <code>velocity</code>: <code>5000.0</code> <p>Constant velocity of the phase in m/s.</p> JSON for ConstantVelocityTracer<pre><code>{\n  \"tracer\": \"ConstantVelocityTracer\",\n  \"phase\": \"constant:P\",\n  \"velocity\": 5000.0\n}\n</code></pre>"},{"location":"components/ray_tracer/#1d-layered-velocity-model","title":"1D Layered Velocity Model","text":"<p>Travel times for 1D layered velocity models can be calculated by two different modules.</p> <p></p> <p>Calculation of travel times in 1D layered media is based on the Pyrocko Cake ray tracer.</p> <p></p> <p>Pyrocko Cake 1D ray tracer for travel time calculation in 1D layered media</p> <p></p>"},{"location":"components/ray_tracer/#exec-11--fastmarchingtracer-module","title":"FastMarchingTracer Module","text":"<p>Travel time calculation for layered 1D velocity models.</p> <p>Calculation is based on fast marching method to solve the Eikonal solution. This the more perfomant than the Pyrocko Cake ray tracer, especially for large number of stations and nodes.</p> Config FastMarchingTracerJSON  <code>velocity_model</code> <p>Velocity model for the ray tracer.</p> <code>interpolation_method</code>: <code>nearest | linear | cubic</code> <p>Interpolation method for travel times in the volume. Choose from <code>nearest</code>, <code>linear</code> or <code>cubic</code>.</p> <code>nthreads</code>: <code>0</code> <p>Number of threads to use for travel time. If set to <code>0</code>, <code>cpu_count*2</code> will be used.</p> <code>implementation</code>: <code>pyrocko | scikit-fmm</code> <p>Implementation of the Fast Marching Method. Pyrocko only supports first-order FMM for now.</p> <code>phases</code> <p>Phases to calculate.</p> JSON for FastMarchingTracer<pre><code>{\n  \"tracer\": \"FastMarching\",\n  \"velocity_model\": {\n    \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n    \"format\": \"nd\",\n    \"crust2_profile\": \"\",\n    \"raw_file_data\": null\n  },\n  \"interpolation_method\": \"linear\",\n  \"nthreads\": 0,\n  \"implementation\": \"pyrocko\",\n  \"phases\": [\n    \"fm:P\",\n    \"fm:S\"\n  ]\n}\n</code></pre>"},{"location":"components/ray_tracer/#exec-12--caketracer-module","title":"CakeTracer Module","text":"<p>Travel time calculation for 1D layered velocity models.</p> <p>Calculation is based on Pyrocko Cake ray tracer.</p> Config CakeTracerJSON  <code>phases</code> <p>Dictionary of phases and timings to calculate.</p> <code>earthmodel</code> <p>Earth model to calculate travel times for.</p> JSON for CakeTracer<pre><code>{\n  \"tracer\": \"CakeTracer\",\n  \"phases\": {\n    \"cake:P\": {\n      \"definition\": \"P,p\"\n    },\n    \"cake:S\": {\n      \"definition\": \"S,s\"\n    }\n  },\n  \"earthmodel\": {\n    \"filename\": \"/home/marius/.cache/qseek/velocity_models/default.nd\",\n    \"format\": \"nd\",\n    \"crust2_profile\": \"\"\n  }\n}\n</code></pre>"},{"location":"components/ray_tracer/#3d-velocity-model","title":"3D Velocity Model \ud83d\ude80","text":"<p>We implement the fast marching method for calculating first arrivals of waves in 3D volumes. Currently three different 3D velocity models are supported:</p> <ul> <li> Import NonLinLoc 3D velocity model</li> <li> 1D layered model \ud83e\udd5e</li> <li> Constant velocity, mainly for testing purposes \ud83e\udd7c</li> </ul> <p></p> <p>Conceptual 2D visualisation for seismic traveltimes calculation in heterogenous media using the fast-marching method for the Eikonal solution is presented. Traveltimes from the receiving station at the surface (indicated by a yellow triangle) towards the subsurface grid are calculated, resulting in station-specifig traveltimes for all potential source locations simultaneously.</p> <p></p>"},{"location":"components/ray_tracer/#exec-13--fastmarching3dtracer-module","title":"FastMarching3DTracer Module","text":"<p>Travel time ray tracer using the Fast Marching Method for 3D earth models.</p> Config FastMarching3DTracerJSON  <code>interpolation_method</code>: <code>nearest | linear | cubic</code> <p>Interpolation method for travel times in the volume. Choose from <code>nearest</code>, <code>linear</code> or <code>cubic</code>.</p> <code>nthreads</code>: <code>0</code> <p>Number of threads to use for travel time. If set to <code>0</code>, <code>cpu_count*2</code> will be used.</p> <code>velocity_model</code> <p>Velocity model for the ray tracer.</p> <code>implementation</code>: <code>pyrocko | scikit-fmm</code> <p>Implementation of the Fast Marching Method. Pyrocko only supports first-order FMM for now.</p> JSON for FastMarching3DTracer<pre><code>{\n  \"tracer\": \"FastMarching3D\",\n  \"phase\": \"fmm3d:P\",\n  \"interpolation_method\": \"cubic\",\n  \"nthreads\": 0,\n  \"velocity_model\": {\n    \"model\": \"Constant3DVelocityModel\",\n    \"grid_spacing\": \"octree\",\n    \"velocity\": 5000.0\n  },\n  \"implementation\": \"scikit-fmm\"\n}\n</code></pre>"},{"location":"components/ray_tracer/#visualizing-3d-models","title":"Visualizing 3D Models","text":"<p>For quality check, all 3D velocity models are exported to <code>vtk/</code> folder as <code>.vti</code> files. Use ParaView to inspect and explore the velocity models.</p> <p> Seismic velocity model of the Utah FORGE testbed site, visualized in ParaView.</p>"},{"location":"components/station_corrections/","title":"Station Corrections","text":"<p>Station corrections can be extract from previous runs to refine the localisation accuracy. The corrections can also help to improve the semblance find more events in a dataset.</p>"},{"location":"components/station_corrections/#station-specific-corrections","title":"Station Specific Corrections","text":"<p>Statistics of station delay times.</p> <p></p>"},{"location":"components/station_corrections/#exec-14--stationcorrections-module","title":"StationCorrections Module","text":"Config StationCorrectionsJSON  <code>import_rundirs</code> <p>Path to rundir, to extract the station corrections from.</p> <code>plot_corrections</code>: <code>False</code> <p>Plot the station corrections statistics.</p> <code>statistic</code>: <code>median | average</code> <p>Arithmetic measure for the traveltime delays. Choose from <code>median</code> and <code>average</code>.</p> <code>weighting</code>: <code>none | confidence | semblance | add-confidence-semblance | mul-confidence-semblance</code> <p>Weighting of the traveltime delays. Choose from <code>none</code>, <code>confidence</code>, <code>semblance</code>, <code>add-confidence-semblance</code> and <code>mul-confidence-semblance</code>.</p> <code>min_num_station_picks</code>: <code>50</code> <p>Minimum number of picks at a station required to calculate station corrections.</p> <code>min_distance_border</code>: <code>500.0</code> <p>Minimum event distance from the border of the octree grid.</p> <code>min_num_picks</code>: <code>3</code> <p>Minimum number of picks per event to be included in the statistics.</p> JSON for StationCorrections<pre><code>{\n  \"corrections\": \"StationCorrections\",\n  \"import_rundirs\": [\n    \".\"\n  ],\n  \"plot_corrections\": false,\n  \"statistic\": \"median\",\n  \"weighting\": \"mul-confidence-semblance\",\n  \"min_num_station_picks\": 50,\n  \"min_distance_border\": 500.0,\n  \"min_num_picks\": 3\n}\n</code></pre>"},{"location":"components/station_corrections/#source-specific-corrections","title":"Source Specific Corrections","text":"<p>Delay volume for a selected stations.</p> <p></p>"},{"location":"components/station_corrections/#exec-15--sourcespecificstationcorrections-module","title":"SourceSpecificStationCorrections Module","text":"<p>Source specific station travel time corrections.</p> Config SourceSpecificStationCorrectionsJSON  <code>import_rundirs</code> <p>Path to rundir, to extract the station corrections from.</p> <code>weighting</code>: <code>none | confidence | semblance | add-confidence-semblance | mul-confidence-semblance</code> <p>Weighting of the traveltime delays. Choose from <code>none</code>, <code>confidence</code>, <code>semblance</code>, <code>add-confidence-semblance</code> and <code>mul-confidence-semblance</code>.</p> <code>min_confidence</code>: <code>5.0</code> <p>Minimum cumulative pick confidence within the sphere surrouding the node. If the cumulative pick confidence inside the sphere is below this value, the sphere radius is increased until enough picks are inside the sphere.</p> <code>min_distance_border</code>: <code>500.0</code> <p>Minimum event distance from the border of the octree grid.</p> <code>min_num_picks</code>: <code>3</code> <p>Minimum number of picks per event to be included in the statistics. Higher values will result in fewer events.</p> <code>spatial_weighting_exponent</code>: <code>3.0</code> <p>The exponent of the spatial weighting function around the sphere.</p> <code>resolution_octree_level</code>: <code>0</code> <p>The octree level (resolution) to use for the station corrections. This is the SSST grid spacing.</p> <code>delay_interpolation_method</code>: <code>nearest | linear | cubic</code> <p>The interpolation method to use for interpolating delays between nodes.</p> JSON for SourceSpecificStationCorrections<pre><code>{\n  \"corrections\": \"SourceSpecificStationCorrections\",\n  \"import_rundirs\": [],\n  \"weighting\": \"mul-confidence-semblance\",\n  \"min_confidence\": 5.0,\n  \"min_distance_border\": 500.0,\n  \"min_num_picks\": 3,\n  \"spatial_weighting_exponent\": 3.0,\n  \"resolution_octree_level\": 0,\n  \"delay_interpolation_method\": \"linear\"\n}\n</code></pre>"},{"location":"components/station_metadata/","title":"Station Metadata","text":"<p>Station metadata is required primarily for station locations and codes.</p> <p>Supported data formats are:</p> <ul> <li> StationXML</li> <li> Pyrocko Station YAML</li> </ul> <p>If local magnitudes M<sub>L</sub> are extracted, response information as StationXML is required.</p> <p></p>"},{"location":"components/station_metadata/#exec-16--stationinventory-module","title":"StationInventory Module","text":"Config StationInventoryJSON  <code>pyrocko_station_yamls</code> <p>List of Pyrocko station YAML files.</p> <code>station_xmls</code> <p>List of StationXML files or directories containing StationXML (.xml) files.</p> <code>blacklist</code> <p>Blacklist stations and exclude from detecion. Format is <code>['NET.STA.LOC', ...]</code>.</p> <code>max_distance</code> <p>Maximum distance in meters from the centroid location to include stations for detection. If None, all stations are included.</p> JSON for StationInventory<pre><code>{\n  \"pyrocko_station_yamls\": [],\n  \"station_xmls\": [],\n  \"blacklist\": [],\n  \"stations\": [],\n  \"max_distance\": null\n}\n</code></pre>"},{"location":"components/waveform_data/","title":"Waveform Data","text":"<p>The seismic can be delivered in MiniSeed or any other format compatible with Pyrocko. Qseek utilizes the Pyrocko Squirrel for fast and asynchronous data access.</p> <p>To prepare your data for EQ detection and localisation, organize it in a MiniSeed file or an SDS structure.</p>"},{"location":"components/waveform_data/#local-waveform-data","title":"Local Waveform Data","text":"<p>To copy large data from FDSN data centers use fdsn-fetch.</p> <p></p>"},{"location":"components/waveform_data/#exec-17--pyrockosquirrel-module","title":"PyrockoSquirrel Module","text":"<p>Waveform provider using Pyrocko's Squirrel.</p> Config PyrockoSquirrelJSON  <code>channel_selector</code> <p>Channel selector for waveforms, e.g. <code>['HH', 'EN']</code>.</p> <code>environment</code> <p>Path to a Pyrocko Squirrel environment.</p> <code>persistent</code> <p>Name of the Squirrel's persistent collection for faster loading of large data sets.</p> <code>waveform_dirs</code> <p>List of directories holding the waveform files.</p> <code>start_time</code> <p>Start time for the search as in ISO8601 as a date or datetime including timezone. E.g. <code>today</code>, <code>yesterday</code>, <code>2025-12-24</code> or <code>2024-12-30T00:00:00Z</code>.</p> <code>end_time</code> <p>Start time for the search as in ISO8601 as a date or datetime including timezone. E.g. <code>today</code>, <code>yesterday</code>, <code>2025-12-24</code> or <code>2024-12-30T00:00:00Z</code>.</p> <code>n_threads</code>: <code>8</code> <p>Number of threads for loading waveforms, important for large data sets.</p> <code>watch_waveforms</code> <p>Watch the waveform directories for changes. If <code>True</code> it will check every ten minutes. If a <code>timedelta</code> is provided it will check every specified time. Default is False.</p> <code>queue_size</code>: <code>16</code> <p>Size of the internal queue for prefetching waveform batches.</p> JSON for PyrockoSquirrel<pre><code>{\n  \"provider\": \"PyrockoSquirrel\",\n  \"channel_selector\": null,\n  \"environment\": null,\n  \"persistent\": \"docs\",\n  \"waveform_dirs\": [\n    \"data\"\n  ],\n  \"start_time\": null,\n  \"end_time\": null,\n  \"n_threads\": 8,\n  \"watch_waveforms\": false,\n  \"queue_size\": 16\n}\n</code></pre>"},{"location":"components/waveform_data/#real-time-waveform-streaming","title":"Real-Time Waveform Streaming","text":""},{"location":"components/waveform_data/#exec-18--seedlink-module","title":"SeedLink Module","text":"<p>Waveform provider to connect to SeedLink real-time streams.</p> Config SeedLinkJSON  <code>channel_selector</code> <p>Channel selector for waveforms, e.g. <code>['HH', 'EN']</code>.</p> <code>timeout</code> <p>Maximum wait time for new traces.</p> <code>clients</code> <p>List of SeedLink clients to connect to. If multiple clients are given, they will be used in parallel.</p> <code>save_sds_archive</code> <p>Path to save MiniSeed in an SDS structure. Give a path to save the archive, or True to use the default path. If False, no saving is done.</p> JSON for SeedLink<pre><code>{\n  \"provider\": \"SeedLink\",\n  \"channel_selector\": null,\n  \"timeout\": \"PT20S\",\n  \"clients\": [\n    {\n      \"host\": \"geofon.gfz-potsdam.de\",\n      \"port\": 18000,\n      \"station_selection\": [\n        {\n          \"nsl\": \"1D.SYRAU.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"1D.WBERG.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.KOC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.KRC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.LBC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.SKC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.STC.\",\n          \"channel\": \"HH?\"\n        },\n        {\n          \"nsl\": \"WB.VAC.\",\n          \"channel\": \"HH?\"\n        }\n      ],\n      \"buffer_length\": \"PT30M\",\n      \"reconnect_timeout\": 60.0\n    }\n  ],\n  \"save_sds_archive\": \"sds-seedlink\"\n}\n</code></pre>"}]}